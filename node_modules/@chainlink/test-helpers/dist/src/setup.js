"use strict";
/**
 * @packageDocumentation
 *
 * This file provides utility functions related to test setup, such as creating a test provider,
 * optimizing test times via snapshots, and making test accounts.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const sol_trace_1 = require("@0x/sol-trace");
const subproviders_1 = require("@0x/subproviders");
const ethers_1 = require("ethers");
const path = tslib_1.__importStar(require("path"));
const debug_1 = require("./debug");
const wallet_1 = require("./wallet");
const debug = debug_1.makeDebug('helpers');
/**
 * Create a test provider which uses an in-memory, in-process chain
 */
function provider() {
    const providerEngine = new sol_trace_1.Web3ProviderEngine();
    providerEngine.addProvider(new subproviders_1.FakeGasEstimateSubprovider(5 * 10 ** 6)); // Ganache does a poor job of estimating gas, so just crank it up for testing.
    if (process.env.DEBUG) {
        debug('Debugging enabled, using sol-trace module...');
        const defaultFromAddress = '';
        const artifactAdapter = new sol_trace_1.SolCompilerArtifactAdapter(path.resolve('dist/artifacts'), path.resolve('contracts'));
        const revertTraceSubprovider = new sol_trace_1.RevertTraceSubprovider(artifactAdapter, defaultFromAddress, true);
        providerEngine.addProvider(revertTraceSubprovider);
    }
    providerEngine.addProvider(new subproviders_1.GanacheSubprovider({ gasLimit: 8000000 }));
    providerEngine.start();
    return new ethers_1.ethers.providers.Web3Provider(providerEngine);
}
exports.provider = provider;
/**
 * This helper function allows us to make use of ganache snapshots,
 * which allows us to snapshot one state instance and revert back to it.
 *
 * This is used to memoize expensive setup calls typically found in beforeEach hooks when we
 * need to setup our state with contract deployments before running assertions.
 *
 * @param provider The provider that's used within the tests
 * @param cb The callback to execute that generates the state we want to snapshot
 */
function snapshot(provider, cb) {
    if (process.env.DEBUG) {
        debug('Debugging enabled, snapshot mode disabled...');
        return cb;
    }
    const d = debug.extend('memoizeDeploy');
    let hasDeployed = false;
    let snapshotId = '';
    return async () => {
        if (!hasDeployed) {
            d('executing deployment..');
            await cb();
            d('snapshotting...');
            /* eslint-disable-next-line require-atomic-updates */
            snapshotId = await provider.send('evm_snapshot', undefined);
            d('snapshot id:%s', snapshotId);
            /* eslint-disable-next-line require-atomic-updates */
            hasDeployed = true;
        }
        else {
            d('reverting to snapshot: %s', snapshotId);
            await provider.send('evm_revert', snapshotId);
            d('re-creating snapshot..');
            /* eslint-disable-next-line require-atomic-updates */
            snapshotId = await provider.send('evm_snapshot', undefined);
            d('recreated snapshot id:%s', snapshotId);
        }
    };
}
exports.snapshot = snapshot;
/**
 * Generate roles and personas for tests along with their correlated account addresses
 */
async function users(provider) {
    const accounts = await Promise.all(Array(8)
        .fill(null)
        .map(async (_, i) => wallet_1.createFundedWallet(provider, i).then(w => w.wallet)));
    const personas = {
        Default: accounts[0],
        Neil: accounts[1],
        Ned: accounts[2],
        Nelly: accounts[3],
        Nancy: accounts[4],
        Norbert: accounts[5],
        Carol: accounts[4],
        Eddy: accounts[5],
    };
    const roles = {
        defaultAccount: accounts[0],
        oracleNode: accounts[1],
        oracleNode1: accounts[2],
        oracleNode2: accounts[3],
        oracleNode3: accounts[4],
        oracleNode4: accounts[5],
        stranger: accounts[6],
        consumer: accounts[7],
    };
    return { personas, roles };
}
exports.users = users;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dXAuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2V0dXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHOzs7QUFFSCw2Q0FJc0I7QUFDdEIsbURBR3lCO0FBQ3pCLG1DQUErQjtBQUMvQixtREFBNEI7QUFDNUIsbUNBQW1DO0FBQ25DLHFDQUE2QztBQUU3QyxNQUFNLEtBQUssR0FBRyxpQkFBUyxDQUFDLFNBQVMsQ0FBQyxDQUFBO0FBRWxDOztHQUVHO0FBQ0gsU0FBZ0IsUUFBUTtJQUN0QixNQUFNLGNBQWMsR0FBRyxJQUFJLDhCQUFrQixFQUFFLENBQUE7SUFDL0MsY0FBYyxDQUFDLFdBQVcsQ0FBQyxJQUFJLHlDQUEwQixDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFDLDhFQUE4RTtJQUV0SixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFO1FBQ3JCLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFBO1FBQ3JELE1BQU0sa0JBQWtCLEdBQUcsRUFBRSxDQUFBO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksc0NBQTBCLENBQ3BELElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsRUFDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FDMUIsQ0FBQTtRQUNELE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxrQ0FBc0IsQ0FDdkQsZUFBZSxFQUNmLGtCQUFrQixFQUNsQixJQUFJLENBQ0wsQ0FBQTtRQUNELGNBQWMsQ0FBQyxXQUFXLENBQUMsc0JBQXNCLENBQUMsQ0FBQTtLQUNuRDtJQUVELGNBQWMsQ0FBQyxXQUFXLENBQUMsSUFBSSxpQ0FBa0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxPQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDM0UsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBRXRCLE9BQU8sSUFBSSxlQUFNLENBQUMs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LFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0tBQ3RCLENBQUE7SUFFRCxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFBO0FBQzVCLENBQUM7QUFoQ0Qsc0JBZ0NDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB0byB0ZXN0IHNldHVwLCBzdWNoIGFzIGNyZWF0aW5nIGEgdGVzdCBwcm92aWRlcixcbiAqIG9wdGltaXppbmcgdGVzdCB0aW1lcyB2aWEgc25hcHNob3RzLCBhbmQgbWFraW5nIHRlc3QgYWNjb3VudHMuXG4gKi9cblxuaW1wb3J0IHtcbiAgUmV2ZXJ0VHJhY2VTdWJwcm92aWRlcixcbiAgU29sQ29tcGlsZXJBcnRpZmFjdEFkYXB0ZXIsXG4gIFdlYjNQcm92aWRlckVuZ2luZSxcbn0gZnJvbSAnQDB4L3NvbC10cmFjZSdcbmltcG9ydCB7XG4gIEZha2VHYXNFc3RpbWF0ZVN1YnByb3ZpZGVyLFxuICBHYW5hY2hlU3VicHJvdmlkZXIsXG59IGZyb20gJ0AweC9zdWJwcm92aWRlcnMnXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgeyBtYWtlRGVidWcgfSBmcm9tICcuL2RlYnVnJ1xuaW1wb3J0IHsgY3JlYXRlRnVuZGVkV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnXG5cbmNvbnN0IGRlYnVnID0gbWFrZURlYnVnKCdoZWxwZXJzJylcblxuLyoqXG4gKiBDcmVhdGUgYSB0ZXN0IHByb3ZpZGVyIHdoaWNoIHVzZXMgYW4gaW4tbWVtb3J5LCBpbi1wcm9jZXNzIGNoYWluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm92aWRlcigpOiBldGhlcnMucHJvdmlkZXJzLkpzb25ScGNQcm92aWRlciB7XG4gIGNvbnN0IHByb3ZpZGVyRW5naW5lID0gbmV3IFdlYjNQcm92aWRlckVuZ2luZSgpXG4gIHByb3ZpZGVyRW5naW5lLmFkZFByb3ZpZGVyKG5ldyBGYWtlR2FzRXN0aW1hdGVTdWJwcm92aWRlcig1ICogMTAgKiogNikpIC8vIEdhbmFjaGUgZG9lcyBhIHBvb3Igam9iIG9mIGVzdGltYXRpbmcgZ2FzLCBzbyBqdXN0IGNyYW5rIGl0IHVwIGZvciB0ZXN0aW5nLlxuXG4gIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGRlYnVnKCdEZWJ1Z2dpbmcgZW5hYmxlZCwgdXNpbmcgc29sLXRyYWNlIG1vZHVsZS4uLicpXG4gICAgY29uc3QgZGVmYXVsdEZyb21BZGRyZXNzID0gJydcbiAgICBjb25zdCBhcnRpZmFjdEFkYXB0ZXIgPSBuZXcgU29sQ29tcGlsZXJBcnRpZmFjdEFkYXB0ZXIoXG4gICAgICBwYXRoLnJlc29sdmUoJ2Rpc3QvYXJ0aWZhY3RzJyksXG4gICAgICBwYXRoLnJlc29sdmUoJ2NvbnRyYWN0cycpLFxuICAgIClcbiAgICBjb25zdCByZXZlcnRUcmFjZVN1YnByb3ZpZGVyID0gbmV3IFJldmVydFRyYWNlU3VicHJvdmlkZXIoXG4gICAgICBhcnRpZmFjdEFkYXB0ZXIsXG4gICAgICBkZWZhdWx0RnJvbUFkZHJlc3MsXG4gICAgICB0cnVlLFxuICAgIClcbiAgICBwcm92aWRlckVuZ2luZS5hZGRQcm92aWRlcihyZXZlcnRUcmFjZVN1YnByb3ZpZGVyKVxuICB9XG5cbiAgcHJvdmlkZXJFbmdpbmUuYWRkUHJvdmlkZXIobmV3IEdhbmFjaGVTdWJwcm92aWRlcih7IGdhc0xpbWl0OiA4XzAwMF8wMDAgfSkpXG4gIHByb3ZpZGVyRW5naW5lLnN0YXJ0KClcblxuICByZXR1cm4gbmV3IGV0aGVycy5wcm92aWRlcnMuV2ViM1Byb3ZpZGVyKHByb3ZpZGVyRW5naW5lKVxufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBtYWtlIHVzZSBvZiBnYW5hY2hlIHNuYXBzaG90cyxcbiAqIHdoaWNoIGFsbG93cyB1cyB0byBzbmFwc2hvdCBvbmUgc3RhdGUgaW5zdGFuY2UgYW5kIHJldmVydCBiYWNrIHRvIGl0LlxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byBtZW1vaXplIGV4cGVuc2l2ZSBzZXR1cCBjYWxscyB0eXBpY2FsbHkgZm91bmQgaW4gYmVmb3JlRWFjaCBob29rcyB3aGVuIHdlXG4gKiBuZWVkIHRvIHNldHVwIG91ciBzdGF0ZSB3aXRoIGNvbnRyYWN0IGRlcGxveW1lbnRzIGJlZm9yZSBydW5uaW5nIGFzc2VydGlvbnMuXG4gKlxuICogQHBhcmFtIHByb3ZpZGVyIFRoZSBwcm92aWRlciB0aGF0J3MgdXNlZCB3aXRoaW4gdGhlIHRlc3RzXG4gKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgdGhhdCBnZW5lcmF0ZXMgdGhlIHN0YXRlIHdlIHdhbnQgdG8gc25hcHNob3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90KFxuICBwcm92aWRlcjogZXRoZXJzLnByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIsXG4gIGNiOiAoKSA9PiBQcm9taXNlPHZvaWQ+LFxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgIGRlYnVnKCdEZWJ1Z2dpbmcgZW5hYmxlZCwgc25hcHNob3QgbW9kZSBkaXNhYmxlZC4uLicpXG5cbiAgICByZXR1cm4gY2JcbiAgfVxuXG4gIGNvbnN0IGQgPSBkZWJ1Zy5leHRlbmQoJ21lbW9pemVEZXBsb3knKVxuICBsZXQgaGFzRGVwbG95ZWQgPSBmYWxzZVxuICBsZXQgc25hcHNob3RJZCA9ICcnXG5cbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWhhc0RlcGxveWVkKSB7XG4gICAgICBkKCdleGVjdXRpbmcgZGVwbG95bWVudC4uJylcbiAgICAgIGF3YWl0IGNiKClcblxuICAgICAgZCgnc25hcHNob3R0aW5nLi4uJylcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzICovXG4gICAgICBzbmFwc2hvdElkID0gYXdhaXQgcHJvdmlkZXIuc2VuZCgnZXZtX3NuYXBzaG90JywgdW5kZWZpbmVkKVxuICAgICAgZCgnc25hcHNob3QgaWQ6JXMnLCBzbmFwc2hvdElkKVxuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlcyAqL1xuICAgICAgaGFzRGVwbG95ZWQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGQoJ3JldmVydGluZyB0byBzbmFwc2hvdDogJXMnLCBzbmFwc2hvdElkKVxuICAgICAgYXdhaXQgcHJvdmlkZXIuc2VuZCgnZXZtX3JldmVydCcsIHNuYXBzaG90SWQpXG5cbiAgICAgIGQoJ3JlLWNyZWF0aW5nIHNuYXBzaG90Li4nKVxuICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXMgKi9cbiAgICAgIHNuYXBzaG90SWQgPSBhd2FpdCBwcm92aWRlci5zZW5kKCdldm1fc25hcHNob3QnLCB1bmRlZmluZWQpXG4gICAgICBkKCdyZWNyZWF0ZWQgc25hcHNob3QgaWQ6JXMnLCBzbmFwc2hvdElkKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvbGVzIHtcbiAgZGVmYXVsdEFjY291bnQ6IGV0aGVycy5XYWxsZXRcbiAgb3JhY2xlTm9kZTogZXRoZXJzLldhbGxldFxuICBvcmFjbGVOb2RlMTogZXRoZXJzLldhbGxldFxuICBvcmFjbGVOb2RlMjogZXRoZXJzLldhbGxldFxuICBvcmFjbGVOb2RlMzogZXRoZXJzLldhbGxldFxuICBvcmFjbGVOb2RlNDogZXRoZXJzLldhbGxldFxuICBzdHJhbmdlcjogZXRoZXJzLldhbGxldFxuICBjb25zdW1lcjogZXRoZXJzLldhbGxldFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcnNvbmFzIHtcbiAgRGVmYXVsdDogZXRoZXJzLldhbGxldFxuICBDYXJvbDogZXRoZXJzLldhbGxldFxuICBFZGR5OiBldGhlcnMuV2FsbGV0XG4gIE5hbmN5OiBldGhlcnMuV2FsbGV0XG4gIE5lZDogZXRoZXJzLldhbGxldFxuICBOZWlsOiBldGhlcnMuV2FsbGV0XG4gIE5lbGx5OiBldGhlcnMuV2FsbGV0XG4gIE5vcmJlcnQ6IGV0aGVycy5XYWxsZXRcbn1cblxuaW50ZXJmYWNlIFVzZXJzIHtcbiAgcm9sZXM6IFJvbGVzXG4gIHBlcnNvbmFzOiBQZXJzb25hc1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHJvbGVzIGFuZCBwZXJzb25hcyBmb3IgdGVzdHMgYWxvbmcgd2l0aCB0aGVpciBjb3JyZWxhdGVkIGFjY291bnQgYWRkcmVzc2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1c2VycyhcbiAgcHJvdmlkZXI6IGV0aGVycy5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyLFxuKTogUHJvbWlzZTxVc2Vycz4ge1xuICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIEFycmF5KDgpXG4gICAgICAuZmlsbChudWxsKVxuICAgICAgLm1hcChhc3luYyAoXywgaSkgPT4gY3JlYXRlRnVuZGVkV2FsbGV0KHByb3ZpZGVyLCBpKS50aGVuKHcgPT4gdy53YWxsZXQpKSxcbiAgKVxuXG4gIGNvbnN0IHBlcnNvbmFzOiBQZXJzb25hcyA9IHtcbiAgICBEZWZhdWx0OiBhY2NvdW50c1swXSxcbiAgICBOZWlsOiBhY2NvdW50c1sxXSxcbiAgICBOZWQ6IGFjY291bnRzWzJdLFxuICAgIE5lbGx5OiBhY2NvdW50c1szXSxcbiAgICBOYW5jeTogYWNjb3VudHNbNF0sXG4gICAgTm9yYmVydDogYWNjb3VudHNbNV0sXG4gICAgQ2Fyb2w6IGFjY291bnRzWzRdLFxuICAgIEVkZHk6IGFjY291bnRzWzVdLFxuICB9XG5cbiAgY29uc3Qgcm9sZXM6IFJvbGVzID0ge1xuICAgIGRlZmF1bHRBY2NvdW50OiBhY2NvdW50c1swXSxcbiAgICBvcmFjbGVOb2RlOiBhY2NvdW50c1sxXSxcbiAgICBvcmFjbGVOb2RlMTogYWNjb3VudHNbMl0sXG4gICAgb3JhY2xlTm9kZTI6IGFjY291bnRzWzNdLFxuICAgIG9yYWNsZU5vZGUzOiBhY2NvdW50c1s0XSxcbiAgICBvcmFjbGVOb2RlNDogYWNjb3VudHNbNV0sXG4gICAgc3RyYW5nZXI6IGFjY291bnRzWzZdLFxuICAgIGNvbnN1bWVyOiBhY2NvdW50c1s3XSxcbiAgfVxuXG4gIHJldHVybiB7IHBlcnNvbmFzLCByb2xlcyB9XG59XG4iXX0=