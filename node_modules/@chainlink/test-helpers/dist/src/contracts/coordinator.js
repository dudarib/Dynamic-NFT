"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * @packageDocumentation
 *
 * This file provides convenience functions to interact with existing solidity contract abstraction libraries, such as
 * @truffle/contract and ethers.js specifically for our `Coordinator.sol` solidity smart contract.
 */
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const helpers_1 = require("../helpers");
const matchers = tslib_1.__importStar(require("../matchers"));
/**
 * Create a service agreement with sane testing defaults
 *
 * @param overrides Values to override service agreement defaults
 */
function serviceAgreement(overrides) {
    const agreement = {
        payment: helpers_1.bigNum('1000000000000000000'),
        expiration: helpers_1.bigNum(300),
        endAt: helpers_1.sixMonthsFromNow(),
        oracles: [],
        requestDigest: '0xbadc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5',
        aggregator: '0x3141592653589793238462643383279502884197',
        aggInitiateJobSelector: '0xd43a12f6',
        aggFulfillSelector: '0x9760168f',
        ...overrides,
    };
    return agreement;
}
exports.serviceAgreement = serviceAgreement;
/**
 * Check that all values for the struct at this SAID have default values.
 *
 * For example, when an invalid service agreement initialization request is made to a `Coordinator`, we want to make sure that
 * it did not initialize its service agreement struct to any value, hence checking for it being empty.
 *
 * @param coordinator The coordinator contract
 * @param serviceAgreementID The service agreement ID
 *
 * @throws when any of payment, expiration, endAt, requestDigest are non-empty
 */
function assertServiceAgreementEmpty(sa) {
    matchers.bigNum(sa.payment, helpers_1.bigNum(0), 'service agreement is not absent');
    matchers.bigNum(sa.expiration, helpers_1.bigNum(0), 'service agreement is not absent');
    matchers.bigNum(sa.endAt, helpers_1.bigNum(0), 'service agreement is not absent');
    chai_1.assert.equal(sa.requestDigest, '0x0000000000000000000000000000000000000000000000000000000000000000');
}
exports.assertServiceAgreementEmpty = assertServiceAgreementEmpty;
/**
 * Create parameters needed for the
 * ```solidity
 *   function initiateServiceAgreement(
 *    bytes memory _serviceAgreementData,
 *    bytes memory _oracleSignaturesData
 *  )
 * ```
 * method of the `Coordinator.sol` contract
 *
 * @param overrides Values to override the defaults for creating a service agreement
 */
async function initiateSAParams(overrides) {
    const sa = serviceAgreement(overrides);
    const signatures = await generateOracleSignatures(sa);
    return [encodeServiceAgreement(sa), encodeOracleSignatures(signatures)];
}
exports.initiateSAParams = initiateSAParams;
const SERVICE_AGREEMENT_TYPES = [
    'uint256',
    'uint256',
    'uint256',
    'address[]',
    'bytes32',
    'address',
    'bytes4',
    'bytes4',
];
/**
 * ABI encode a service agreement object
 *
 * @param sa The service agreement to encode
 */
function encodeServiceAgreement(sa) {
    return ethers_1.ethers.utils.defaultAbiCoder.encode(SERVICE_AGREEMENT_TYPES, serviceAgreementValues(sa));
}
exports.encodeServiceAgreement = encodeServiceAgreement;
/**
 * Generate the unique identifier of a service agreement by computing its
 * digest.
 *
 * @param sa The service agreement to compute the digest of
 */
function generateSAID(sa) {
    return ethers_1.ethers.utils.solidityKeccak256(SERVICE_AGREEMENT_TYPES, serviceAgreementValues(sa));
}
exports.generateSAID = generateSAID;
/**
 * ABI encode the javascript representation of OracleSignatures
 *```solidity
 *  struct OracleSignatures {
 *    uint8[] vs;
 *    bytes32[] rs;
 *    bytes32[] ss;
 *  }
 * ```
 *
 * @param os The oracle signatures to ABI encode
 */
function encodeOracleSignatures(os) {
    const ORACLE_SIGNATURES_TYPES = ['uint8[]', 'bytes32[]', 'bytes32[]'];
    const osValues = [os.vs, os.rs, os.ss];
    return ethers_1.ethers.utils.defaultAbiCoder.encode(ORACLE_SIGNATURES_TYPES, osValues);
}
exports.encodeOracleSignatures = encodeOracleSignatures;
/**
 * Abi encode the oracleRequest() method for `Coordinator.sol`
 * ```solidity
 *  function oracleRequest(
 *    address _sender,
 *    uint256 _amount,
 *    bytes32 _sAId,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _nonce,
 *    uint256 _dataVersion,
 *    bytes calldata _data
 *  )
 * ```
 *
 * @param sAID The service agreement ID
 * @param callbackAddr The callback contract address for the response
 * @param callbackFunctionId The callback function id for the response
 * @param nonce The nonce sent by the requester
 * @param data The CBOR payload of the request
 */
function encodeOracleRequest(specId, to, fHash, nonce, dataBytes) {
    const oracleRequestSighash = '0x40429946';
    const oracleRequestInputs = [
        { name: '_sender', type: 'address' },
        { name: '_amount', type: 'uint256' },
        { name: '_sAId', type: 'bytes32' },
        { name: '_callbackAddress', type: 'address' },
        { name: '_callbackFunctionId', type: 'bytes4' },
        { name: '_nonce', type: 'uint256' },
        { name: '_dataVersion', type: 'uint256' },
        { name: '_data', type: 'bytes' },
    ];
    const encodedParams = ethers_1.ethers.utils.defaultAbiCoder.encode(oracleRequestInputs.map(i => i.type), [ethers_1.ethers.constants.AddressZero, 0, specId, to, fHash, nonce, 1, dataBytes]);
    return `${oracleRequestSighash}${helpers_1.stripHexPrefix(encodedParams)}`;
}
exports.encodeOracleRequest = encodeOracleRequest;
/**
 * Generates the oracle signatures on a ServiceAgreement
 *
 * @param serviceAgreement The service agreement to sign
 * @param signers The list oracles that will sign the service agreement
 */
async function generateOracleSignatures(serviceAgreement) {
    const sAID = generateSAID(serviceAgreement);
    const signatures = [];
    for (let i = 0; i < serviceAgreement.oracles.length; i++) {
        const oracle = serviceAgreement.oracles[i];
        if (!(oracle instanceof ethers_1.ethers.Wallet)) {
            throw Error('cannot generate signatures without oracle wallets');
        }
        const oracleSignature = await personalSign(sAID, oracle);
        const requestDigestAddr = recoverAddressFromSignature(sAID, oracleSignature);
        chai_1.assert.equal(oracle.address, requestDigestAddr);
        signatures.push(oracleSignature);
    }
    return combineOracleSignatures(signatures);
}
exports.generateOracleSignatures = generateOracleSignatures;
/**
 * Signs a message according to ethereum specs by first appending
 * "\x19Ethereum Signed Message:\n' + <message.length>" to the message
 *
 * @param message The message to sign - either a Buffer or a hex string
 * @param wallet The wallet of the signer
 */
async function personalSign(message, wallet) {
    if (message instanceof String && !ethers_1.utils.isHexString(message)) {
        throw Error(`The message ${message} is not a valid hex string`);
    }
    const flatSig = await wallet.signMessage(ethers_1.utils.arrayify(message));
    const splitSignature = ethers_1.utils.splitSignature(flatSig);
    function assertIsSignature(sig) {
        if (!sig.v)
            throw Error(`Could not extract v from signature`);
    }
    assertIsSignature(splitSignature);
    return splitSignature;
}
exports.personalSign = personalSign;
/**
 * Recovers the address of the signer of a message
 *
 * @param message The message that was signed
 * @param signature The signature on the message
 */
function recoverAddressFromSignature(message, signature) {
    const messageBuff = ethers_1.utils.arrayify(message);
    return ethers_1.utils.verifyMessage(messageBuff, signature);
}
exports.recoverAddressFromSignature = recoverAddressFromSignature;
/**
 * Combine v, r, and s params of multiple signatures into format expected by contracts
 *
 * @param signatures The list of signatures to combine
 */
function combineOracleSignatures(signatures) {
    return signatures.reduce((prev, { v, r, s }) => {
        prev.vs.push(v);
        prev.rs.push(r);
        prev.ss.push(s);
        return prev;
    }, { vs: [], rs: [], ss: [] });
}
exports.combineOracleSignatures = combineOracleSignatures;
function serviceAgreementValues(sa) {
    return [
        sa.payment,
        sa.expiration,
        sa.endAt,
        sa.oracles.map(o => (o instanceof ethers_1.ethers.Wallet ? o.address : o)),
        sa.requestDigest,
        sa.aggregator,
        sa.aggInitiateJobSelector,
        sa.aggFulfillSelector,
    ];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29vcmRpbmF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJhY3RzL2Nvb3JkaW5hdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7OztHQUtHO0FBQ0gsK0JBQTZCO0FBQzdCLG1DQUFzQztBQUV0Qyx3Q0FBcUU7QUFDckUsOERBQXVDO0FBeUZ2Qzs7OztHQUlHO0FBQ0gsU0FBZ0IsZ0JBQWdCLENBQzlCLFNBQW9DO0lBRXBDLE1BQU0sU0FBUyxHQUFxQjtRQUNsQyxPQUFPLEVBQUUsZ0JBQU0sQ0FBQyxxQkFBcUIsQ0FBQztRQUN0QyxVQUFVLEVBQUUsZ0JBQU0sQ0FBQyxHQUFHLENBQUM7UUFDdkIsS0FBSyxFQUFFLDBCQUFnQixFQUFFO1FBQ3pCLE9BQU8sRUFBRSxFQUFFO1FBQ1gsYUFBYSxFQUNYLG9FQUFvRTtRQUN0RSxVQUFVLEVBQUUsNENBQTRDO1FBQ3hELHNCQUFzQixFQUFFLFlBQVk7UUFDcEMsa0JBQWtCLEVBQUUsWUFBWTtRQUNoQyxHQUFHLFNBQVM7S0FDYixDQUFBO0lBRUQsT0FBTyxTQUFTLENBQUE7QUFDbEIsQ0FBQztBQWpCRCw0Q0FpQkM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsMkJBQTJCLENBQ3pDLEVBQXFDO0lBRXJDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxnQkFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLGlDQUFpQyxDQUFDLENBQUE7SUFDekUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLGdCQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUNBQWlDLENBQUMsQ0FBQTtJQUM1RSxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsZ0JBQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxpQ0FBaUMsQ0FBQyxDQUFBO0lBQ3ZFLGFBQU0sQ0FBQyxLQUFLLENBQ1YsRUFBRSxDQUFD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RWYsT0FBTyxJQUFJLENBQUE7SUFDYixDQUFDLEVBQ0QsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUMzQixDQUFBO0FBQ0gsQ0FBQztBQWJELDBEQWFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxFQUFvQjtJQUNsRCxPQUFPO1FBQ0wsRUFBRSxDQUFDLE9BQU87UUFDVixFQUFFLENBQUMsVUFBVTtRQUNiLEVBQUUsQ0FBQyxLQUFLO1FBQ1IsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxlQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRSxFQUFFLENBQUMsYUFBYTtRQUNoQixFQUFFLENBQUMsVUFBVTtRQUNiLEVBQUUsQ0FBQyxzQkFBc0I7UUFDekIsRUFBRSxDQUFDLGtCQUFrQjtLQUN0QixDQUFBO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIGV4aXN0aW5nIHNvbGlkaXR5IGNvbnRyYWN0IGFic3RyYWN0aW9uIGxpYnJhcmllcywgc3VjaCBhc1xuICogQHRydWZmbGUvY29udHJhY3QgYW5kIGV0aGVycy5qcyBzcGVjaWZpY2FsbHkgZm9yIG91ciBgQ29vcmRpbmF0b3Iuc29sYCBzb2xpZGl0eSBzbWFydCBjb250cmFjdC5cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnY2hhaSdcbmltcG9ydCB7IGV0aGVycywgdXRpbHMgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgeyBCaWdOdW1iZXJpc2ggfSBmcm9tICdldGhlcnMvdXRpbHMnXG5pbXBvcnQgeyBiaWdOdW0sIHNpeE1vbnRoc0Zyb21Ob3csIHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnLi4vaGVscGVycydcbmltcG9ydCAqIGFzIG1hdGNoZXJzIGZyb20gJy4uL21hdGNoZXJzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZpY2VBZ3JlZW1lbnQge1xuICAvKipcbiAgICogUHJpY2UgaW4gTElOSyB0byByZXF1ZXN0IGEgcmVwb3J0IGJhc2VkIG9uIHRoaXMgYWdyZWVtZW50XG4gICAqXG4gICAqIEBzb2xmb3JtYXQgdWludDI1NlxuICAgKi9cbiAgcGF5bWVudDogZXRoZXJzLnV0aWxzLkJpZ051bWJlcmlzaFxuICAvKipcbiAgICogRXhwaXJhdGlvbiBpcyB0aGUgYW1vdW50IG9mIHRpbWUgYW4gb3JhY2xlIGhhcyB0byBhbnN3ZXIgYSByZXF1ZXN0XG4gICAqXG4gICAqIEBzb2xmb3JtYXQgdWludDI1NlxuICAgKi9cbiAgZXhwaXJhdGlvbjogZXRoZXJzLnV0aWxzLkJpZ051bWJlcmlzaFxuICAvKipcbiAgICogVGhlIHNlcnZpY2UgYWdyZWVtZW50IGlzIHZhbGlkIHVudGlsIHRoaXMgdGltZVxuICAgKlxuICAgKiBAc29sZm9ybWF0IHVpbnQyNTZcbiAgICovXG4gIGVuZEF0OiBldGhlcnMudXRpbHMuQmlnTnVtYmVyaXNoXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBvcmFjbGUgYWRkcmVzc2VzIHRvIHVzZSB3aXRoaW4gdGhlIHByb2Nlc3Mgb2YgYWdncmVnYXRpb25cbiAgICpcbiAgICogQHNvbGZvcm1hdCBhZGRyZXNzW11cbiAgICovXG4gIG9yYWNsZXM6IChzdHJpbmcgfCBldGhlcnMuV2FsbGV0KVtdXG4gIC8qKlxuICAgKiBUaGlzIGVmZmVjdGl2ZWx5IGZ1bmN0aW9ucyBhcyBhbiBJRCB0YWcgZm9yIHRoZSBvZmYtY2hhaW4gam9iIG9mIHRoZVxuICAgKiBzZXJ2aWNlIGFncmVlbWVudC4gSXQgaXMgY2FsY3VsYXRlZCBhcyB0aGUga2VjY2FrMjU2IGhhc2ggb2YgdGhlXG4gICAqIG5vcm1hbGl6ZWQgSlNPTiByZXF1ZXN0IHRvIGNyZWF0ZSB0aGUgU2VydmljZUFncmVlbWVudCwgYnV0IHRoYXQgaWRlbnRpdHlcbiAgICogaXMgdW51c2VkLCBhbmQgaXRzIHZhbHVlIGlzIGVzc2VudGlhbGx5IGFyYml0cmFyeS5cbiAgICpcbiAgICogQHNvbGZvcm1hdCBieXRlczMyXG4gICAqL1xuICByZXF1ZXN0RGlnZXN0OiBzdHJpbmdcblxuICAvKipcbiAgICogIFNwZWNpZmljYXRpb24gb2YgYWdncmVnYXRvciBpbnRlcmZhY2UuIFNlZSAuLi8uLi8uLi9ldm0vY29udHJhY3RzL3Rlc3RzL01lYW5BZ2dyZWdhdG9yLnNvbFxuICAgKiAgZm9yIGV4YW1wbGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBZGRyZXNzIG9mIHdoZXJlIHRoZSBhZ2dyZWdhdG9yIGluc3RhbmNlIGlzIGhlbGRcbiAgICpcbiAgICogQHNvbGZvcm1hdCBhZGRyZXNzXG4gICAqL1xuICBhZ2dyZWdhdG9yOiBzdHJpbmdcbiAgLyoqXG4gICAqIFNlbGVjdG9ycyBmb3IgdGhlIGludGVyZmFjZSBtZXRob2RzIG11c3QgYmUgc3BlY2lmaWVkLCBiZWNhdXNlIHRoZWlyXG4gICAqIGFyZ3VtZW50cyBjYW4gdmFyeSBmcm9tIGFnZ3JlZ2F0b3IgdG8gYWdncmVnYXRvci5cbiAgICpcbiAgICogRnVuY3Rpb24gc2VsZWN0b3IgZm9yIGFnZ3JlZ2F0b3IgaW5pdGlhdGVKb2IgbWV0aG9kXG4gICAqXG4gICAqIEBzb2xmb3JtYXQgYnl0ZXM0XG4gICAqL1xuICBhZ2dJbml0aWF0ZUpvYlNlbGVjdG9yOiBzdHJpbmdcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHNlbGVjdG9yIGZvciBhZ2dyZWdhdG9yIGZ1bGZpbGwgbWV0aG9kXG4gICAqXG4gICAqIEBzb2xmb3JtYXQgYnl0ZXM0XG4gICAqL1xuICBhZ2dGdWxmaWxsU2VsZWN0b3I6IHN0cmluZ1xufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBtdWx0aXBsZSBvcmFjbGUgc2lnbmF0dXJlcyBzdG9yZWQgdmlhIHBhcmFsbGVsIGFycmF5c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE9yYWNsZVNpZ25hdHVyZXMge1xuICAvKipcbiAgICogVGhlIHJlY292ZXJ5IHBhcmFtZXRlcnMgbm9ybWFsaXplZCBmb3IgU29saWRpdHksIGVpdGhlciAyNyBvciAyOFxuICAgKlxuICAgKiBAc29sZm9ybWF0IHVpbnQ4W11cbiAgICovXG4gIHZzOiBldGhlcnMudXRpbHMuQmlnTnVtYmVyaXNoW11cbiAgLyoqXG4gICAqIHRoZSByIGNvb3JkaW5hdGUgd2l0aGluIChyLCBzKSBwdWJsaWMgcG9pbnQgb2YgYSBzaWduYXR1cmVcbiAgICpcbiAgICogQHNvbGZvcm1hdCBieXRlczMyW11cbiAgICovXG4gIHJzOiBzdHJpbmdbXVxuICAvKipcbiAgICogdGhlIHMgY29vcmRpbmF0ZSB3aXRoaW4gKHIsIHMpIHB1YmxpYyBwb2ludCBvZiBhIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAc29sZm9ybWF0ICBieXRlczMyW11cbiAgICovXG4gIHNzOiBzdHJpbmdbXVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNlcnZpY2UgYWdyZWVtZW50IHdpdGggc2FuZSB0ZXN0aW5nIGRlZmF1bHRzXG4gKlxuICogQHBhcmFtIG92ZXJyaWRlcyBWYWx1ZXMgdG8gb3ZlcnJpZGUgc2VydmljZSBhZ3JlZW1lbnQgZGVmYXVsdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcnZpY2VBZ3JlZW1lbnQoXG4gIG92ZXJyaWRlczogUGFydGlhbDxTZXJ2aWNlQWdyZWVtZW50Pixcbik6IFNlcnZpY2VBZ3JlZW1lbnQge1xuICBjb25zdCBhZ3JlZW1lbnQ6IFNlcnZpY2VBZ3JlZW1lbnQgPSB7XG4gICAgcGF5bWVudDogYmlnTnVtKCcxMDAwMDAwMDAwMDAwMDAwMDAwJyksXG4gICAgZXhwaXJhdGlvbjogYmlnTnVtKDMwMCksXG4gICAgZW5kQXQ6IHNpeE1vbnRoc0Zyb21Ob3coKSxcbiAgICBvcmFjbGVzOiBbXSxcbiAgICByZXF1ZXN0RGlnZXN0OlxuICAgICAgJzB4YmFkYzBkZTViYWRjMGRlNWJhZGMwZGU1YmFkYzBkZTViYWRjMGRlNWJhZGMwZGU1YmFkYzBkZTViYWRjMGRlNScsXG4gICAgYWdncmVnYXRvcjogJzB4MzE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NycsXG4gICAgYWdnSW5pdGlhdGVKb2JTZWxlY3RvcjogJzB4ZDQzYTEyZjYnLFxuICAgIGFnZ0Z1bGZpbGxTZWxlY3RvcjogJzB4OTc2MDE2OGYnLFxuICAgIC4uLm92ZXJyaWRlcyxcbiAgfVxuXG4gIHJldHVybiBhZ3JlZW1lbnRcbn1cblxuLyoqXG4gKiBDaGVjayB0aGF0IGFsbCB2YWx1ZXMgZm9yIHRoZSBzdHJ1Y3QgYXQgdGhpcyBTQUlEIGhhdmUgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gYW4gaW52YWxpZCBzZXJ2aWNlIGFncmVlbWVudCBpbml0aWFsaXphdGlvbiByZXF1ZXN0IGlzIG1hZGUgdG8gYSBgQ29vcmRpbmF0b3JgLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0XG4gKiBpdCBkaWQgbm90IGluaXRpYWxpemUgaXRzIHNlcnZpY2UgYWdyZWVtZW50IHN0cnVjdCB0byBhbnkgdmFsdWUsIGhlbmNlIGNoZWNraW5nIGZvciBpdCBiZWluZyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gY29vcmRpbmF0b3IgVGhlIGNvb3JkaW5hdG9yIGNvbnRyYWN0XG4gKiBAcGFyYW0gc2VydmljZUFncmVlbWVudElEIFRoZSBzZXJ2aWNlIGFncmVlbWVudCBJRFxuICpcbiAqIEB0aHJvd3Mgd2hlbiBhbnkgb2YgcGF5bWVudCwgZXhwaXJhdGlvbiwgZW5kQXQsIHJlcXVlc3REaWdlc3QgYXJlIG5vbi1lbXB0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2VydmljZUFncmVlbWVudEVtcHR5KFxuICBzYTogT21pdDxTZXJ2aWNlQWdyZWVtZW50LCAnb3JhY2xlcyc+LFxuKSB7XG4gIG1hdGNoZXJzLmJpZ051bShzYS5wYXltZW50LCBiaWdOdW0oMCksICdzZXJ2aWNlIGFncmVlbWVudCBpcyBub3QgYWJzZW50JylcbiAgbWF0Y2hlcnMuYmlnTnVtKHNhLmV4cGlyYXRpb24sIGJpZ051bSgwKSwgJ3NlcnZpY2UgYWdyZWVtZW50IGlzIG5vdCBhYnNlbnQnKVxuICBtYXRjaGVycy5iaWdOdW0oc2EuZW5kQXQsIGJpZ051bSgwKSwgJ3NlcnZpY2UgYWdyZWVtZW50IGlzIG5vdCBhYnNlbnQnKVxuICBhc3NlcnQuZXF1YWwoXG4gICAgc2EucmVxdWVzdERpZ2VzdCxcbiAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgKVxufVxuXG4vKipcbiAqIENyZWF0ZSBwYXJhbWV0ZXJzIG5lZWRlZCBmb3IgdGhlXG4gKiBgYGBzb2xpZGl0eVxuICogICBmdW5jdGlvbiBpbml0aWF0ZVNlcnZpY2VBZ3JlZW1lbnQoXG4gKiAgICBieXRlcyBtZW1vcnkgX3NlcnZpY2VBZ3JlZW1lbnREYXRhLFxuICogICAgYnl0ZXMgbWVtb3J5IF9vcmFjbGVTaWduYXR1cmVzRGF0YVxuICogIClcbiAqIGBgYFxuICogbWV0aG9kIG9mIHRoZSBgQ29vcmRpbmF0b3Iuc29sYCBjb250cmFjdFxuICpcbiAqIEBwYXJhbSBvdmVycmlkZXMgVmFsdWVzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cyBmb3IgY3JlYXRpbmcgYSBzZXJ2aWNlIGFncmVlbWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhdGVTQVBhcmFtcyhcbiAgb3ZlcnJpZGVzOiBQYXJ0aWFsPFNlcnZpY2VBZ3JlZW1lbnQ+LFxuKTogUHJvbWlzZTxbc3RyaW5nLCBzdHJpbmddPiB7XG4gIGNvbnN0IHNhID0gc2VydmljZUFncmVlbWVudChvdmVycmlkZXMpXG4gIGNvbnN0IHNpZ25hdHVyZXMgPSBhd2FpdCBnZW5lcmF0ZU9yYWNsZVNpZ25hdHVyZXMoc2EpXG5cbiAgcmV0dXJuIFtlbmNvZGVTZXJ2aWNlQWdyZWVtZW50KHNhKSwgZW5jb2RlT3JhY2xlU2lnbmF0dXJlcyhzaWduYXR1cmVzKV1cbn1cblxuY29uc3QgU0VSVklDRV9BR1JFRU1FTlRfVFlQRVMgPSBbXG4gICd1aW50MjU2JyxcbiAgJ3VpbnQyNTYnLFxuICAndWludDI1NicsXG4gICdhZGRyZXNzW10nLFxuICAnYnl0ZXMzMicsXG4gICdhZGRyZXNzJyxcbiAgJ2J5dGVzNCcsXG4gICdieXRlczQnLFxuXVxuXG4vKipcbiAqIEFCSSBlbmNvZGUgYSBzZXJ2aWNlIGFncmVlbWVudCBvYmplY3RcbiAqXG4gKiBAcGFyYW0gc2EgVGhlIHNlcnZpY2UgYWdyZWVtZW50IHRvIGVuY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU2VydmljZUFncmVlbWVudChzYTogU2VydmljZUFncmVlbWVudCkge1xuICByZXR1cm4gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoXG4gICAgU0VSVklDRV9BR1JFRU1FTlRfVFlQRVMsXG4gICAgc2VydmljZUFncmVlbWVudFZhbHVlcyhzYSksXG4gIClcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgYSBzZXJ2aWNlIGFncmVlbWVudCBieSBjb21wdXRpbmcgaXRzXG4gKiBkaWdlc3QuXG4gKlxuICogQHBhcmFtIHNhIFRoZSBzZXJ2aWNlIGFncmVlbWVudCB0byBjb21wdXRlIHRoZSBkaWdlc3Qgb2ZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU0FJRChcbiAgc2E6IFNlcnZpY2VBZ3JlZW1lbnQsXG4pOiBSZXR1cm5UeXBlPHR5cGVvZiBldGhlcnMudXRpbHMua2VjY2FrMjU2PiB7XG4gIHJldHVybiBldGhlcnMudXRpbHMuc29saWRpdHlLZWNjYWsyNTYoXG4gICAgU0VSVklDRV9BR1JFRU1FTlRfVFlQRVMsXG4gICAgc2VydmljZUFncmVlbWVudFZhbHVlcyhzYSksXG4gIClcbn1cblxuLyoqXG4gKiBBQkkgZW5jb2RlIHRoZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIE9yYWNsZVNpZ25hdHVyZXNcbiAqYGBgc29saWRpdHlcbiAqICBzdHJ1Y3QgT3JhY2xlU2lnbmF0dXJlcyB7XG4gKiAgICB1aW50OFtdIHZzO1xuICogICAgYnl0ZXMzMltdIHJzO1xuICogICAgYnl0ZXMzMltdIHNzO1xuICogIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcyBUaGUgb3JhY2xlIHNpZ25hdHVyZXMgdG8gQUJJIGVuY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlT3JhY2xlU2lnbmF0dXJlcyhvczogT3JhY2xlU2lnbmF0dXJlcykge1xuICBjb25zdCBPUkFDTEVfU0lHTkFUVVJFU19UWVBFUyA9IFsndWludDhbXScsICdieXRlczMyW10nLCAnYnl0ZXMzMltdJ11cbiAgY29uc3Qgb3NWYWx1ZXMgPSBbb3MudnMsIG9zLnJzLCBvcy5zc11cblxuICByZXR1cm4gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoT1JBQ0xFX1NJR05BVFVSRVNfVFlQRVMsIG9zVmFsdWVzKVxufVxuXG4vKipcbiAqIEFiaSBlbmNvZGUgdGhlIG9yYWNsZVJlcXVlc3QoKSBtZXRob2QgZm9yIGBDb29yZGluYXRvci5zb2xgXG4gKiBgYGBzb2xpZGl0eVxuICogIGZ1bmN0aW9uIG9yYWNsZVJlcXVlc3QoXG4gKiAgICBhZGRyZXNzIF9zZW5kZXIsXG4gKiAgICB1aW50MjU2IF9hbW91bnQsXG4gKiAgICBieXRlczMyIF9zQUlkLFxuICogICAgYWRkcmVzcyBfY2FsbGJhY2tBZGRyZXNzLFxuICogICAgYnl0ZXM0IF9jYWxsYmFja0Z1bmN0aW9uSWQsXG4gKiAgICB1aW50MjU2IF9ub25jZSxcbiAqICAgIHVpbnQyNTYgX2RhdGFWZXJzaW9uLFxuICogICAgYnl0ZXMgY2FsbGRhdGEgX2RhdGFcbiAqICApXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc0FJRCBUaGUgc2VydmljZSBhZ3JlZW1lbnQgSURcbiAqIEBwYXJhbSBjYWxsYmFja0FkZHIgVGhlIGNhbGxiYWNrIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoZSByZXNwb25zZVxuICogQHBhcmFtIGNhbGxiYWNrRnVuY3Rpb25JZCBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaWQgZm9yIHRoZSByZXNwb25zZVxuICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBzZW50IGJ5IHRoZSByZXF1ZXN0ZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBDQk9SIHBheWxvYWQgb2YgdGhlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU9yYWNsZVJlcXVlc3QoXG4gIHNwZWNJZDogc3RyaW5nLFxuICB0bzogc3RyaW5nLFxuICBmSGFzaDogc3RyaW5nLFxuICBub25jZTogQmlnTnVtYmVyaXNoLFxuICBkYXRhQnl0ZXM6IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IG9yYWNsZVJlcXVlc3RTaWdoYXNoID0gJzB4NDA0Mjk5NDYnXG4gIGNvbnN0IG9yYWNsZVJlcXVlc3RJbnB1dHMgPSBbXG4gICAgeyBuYW1lOiAnX3NlbmRlcicsIHR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIHsgbmFtZTogJ19hbW91bnQnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICB7IG5hbWU6ICdfc0FJZCcsIHR5cGU6ICdieXRlczMyJyB9LFxuICAgIHsgbmFtZTogJ19jYWxsYmFja0FkZHJlc3MnLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICB7IG5hbWU6ICdfY2FsbGJhY2tGdW5jdGlvbklkJywgdHlwZTogJ2J5dGVzNCcgfSxcbiAgICB7IG5hbWU6ICdfbm9uY2UnLCB0eXBlOiAndWludDI1NicgfSxcbiAgICB7IG5hbWU6ICdfZGF0YVZlcnNpb24nLCB0eXBlOiAndWludDI1NicgfSxcbiAgICB7IG5hbWU6ICdfZGF0YScsIHR5cGU6ICdieXRlcycgfSxcbiAgXVxuXG4gIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBldGhlcnMudXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShcbiAgICBvcmFjbGVSZXF1ZXN0SW5wdXRzLm1hcChpID0+IGkudHlwZSksXG4gICAgW2V0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8sIDAsIHNwZWNJZCwgdG8sIGZIYXNoLCBub25jZSwgMSwgZGF0YUJ5dGVzXSxcbiAgKVxuXG4gIHJldHVybiBgJHtvcmFjbGVSZXF1ZXN0U2lnaGFzaH0ke3N0cmlwSGV4UHJlZml4KGVuY29kZWRQYXJhbXMpfWBcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIG9yYWNsZSBzaWduYXR1cmVzIG9uIGEgU2VydmljZUFncmVlbWVudFxuICpcbiAqIEBwYXJhbSBzZXJ2aWNlQWdyZWVtZW50IFRoZSBzZXJ2aWNlIGFncmVlbWVudCB0byBzaWduXG4gKiBAcGFyYW0gc2lnbmVycyBUaGUgbGlzdCBvcmFjbGVzIHRoYXQgd2lsbCBzaWduIHRoZSBzZXJ2aWNlIGFncmVlbWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPcmFjbGVTaWduYXR1cmVzKFxuICBzZXJ2aWNlQWdyZWVtZW50OiBTZXJ2aWNlQWdyZWVtZW50LFxuKTogUHJvbWlzZTxPcmFjbGVTaWduYXR1cmVzPiB7XG4gIGNvbnN0IHNBSUQgPSBnZW5lcmF0ZVNBSUQoc2VydmljZUFncmVlbWVudClcbiAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2aWNlQWdyZWVtZW50Lm9yYWNsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvcmFjbGUgPSBzZXJ2aWNlQWdyZWVtZW50Lm9yYWNsZXNbaV1cbiAgICBpZiAoIShvcmFjbGUgaW5zdGFuY2VvZiBldGhlcnMuV2FsbGV0KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2Nhbm5vdCBnZW5lcmF0ZSBzaWduYXR1cmVzIHdpdGhvdXQgb3JhY2xlIHdhbGxldHMnKVxuICAgIH1cbiAgICBjb25zdCBvcmFjbGVTaWduYXR1cmUgPSBhd2FpdCBwZXJzb25hbFNpZ24oc0FJRCwgb3JhY2xlKVxuICAgIGNvbnN0IHJlcXVlc3REaWdlc3RBZGRyID0gcmVjb3ZlckFkZHJlc3NGcm9tU2lnbmF0dXJlKHNBSUQsIG9yYWNsZVNpZ25hdHVyZSlcbiAgICBhc3NlcnQuZXF1YWwob3JhY2xlLmFkZHJlc3MsIHJlcXVlc3REaWdlc3RBZGRyKVxuICAgIHNpZ25hdHVyZXMucHVzaChvcmFjbGVTaWduYXR1cmUpXG4gIH1cblxuICByZXR1cm4gY29tYmluZU9yYWNsZVNpZ25hdHVyZXMoc2lnbmF0dXJlcylcbn1cblxuLyoqXG4gKiBTaWducyBhIG1lc3NhZ2UgYWNjb3JkaW5nIHRvIGV0aGVyZXVtIHNwZWNzIGJ5IGZpcnN0IGFwcGVuZGluZ1xuICogXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyA8bWVzc2FnZS5sZW5ndGg+XCIgdG8gdGhlIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzaWduIC0gZWl0aGVyIGEgQnVmZmVyIG9yIGEgaGV4IHN0cmluZ1xuICogQHBhcmFtIHdhbGxldCBUaGUgd2FsbGV0IG9mIHRoZSBzaWduZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsU2lnbihcbiAgbWVzc2FnZTogQnVmZmVyIHwgc3RyaW5nLFxuICB3YWxsZXQ6IGV0aGVycy5XYWxsZXQsXG4pOiBQcm9taXNlPFJlcXVpcmVkPHV0aWxzLlNpZ25hdHVyZT4+IHtcbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBTdHJpbmcgJiYgIXV0aWxzLmlzSGV4U3RyaW5nKG1lc3NhZ2UpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFRoZSBtZXNzYWdlICR7bWVzc2FnZX0gaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZ2ApXG4gIH1cblxuICBjb25zdCBmbGF0U2lnID0gYXdhaXQgd2FsbGV0LnNpZ25NZXNzYWdlKHV0aWxzLmFycmF5aWZ5KG1lc3NhZ2UpKVxuICBjb25zdCBzcGxpdFNpZ25hdHVyZSA9IHV0aWxzLnNwbGl0U2lnbmF0dXJlKGZsYXRTaWcpXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SXNTaWduYXR1cmUoXG4gICAgc2lnOiB1dGlscy5TaWduYXR1cmUsXG4gICk6IGFzc2VydHMgc2lnIGlzIFJlcXVpcmVkPHV0aWxzLlNpZ25hdHVyZT4ge1xuICAgIGlmICghc2lnLnYpIHRocm93IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCB2IGZyb20gc2lnbmF0dXJlYClcbiAgfVxuICBhc3NlcnRJc1NpZ25hdHVyZShzcGxpdFNpZ25hdHVyZSlcblxuICByZXR1cm4gc3BsaXRTaWduYXR1cmVcbn1cblxuLyoqXG4gKiBSZWNvdmVycyB0aGUgYWRkcmVzcyBvZiB0aGUgc2lnbmVyIG9mIGEgbWVzc2FnZVxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHNpZ25lZFxuICogQHBhcmFtIHNpZ25hdHVyZSBUaGUgc2lnbmF0dXJlIG9uIHRoZSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzc0Zyb21TaWduYXR1cmUoXG4gIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcixcbiAgc2lnbmF0dXJlOiBSZXF1aXJlZDx1dGlscy5TaWduYXR1cmU+LFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbWVzc2FnZUJ1ZmYgPSB1dGlscy5hcnJheWlmeShtZXNzYWdlKVxuICByZXR1cm4gdXRpbHMudmVyaWZ5TWVzc2FnZShtZXNzYWdlQnVmZiwgc2lnbmF0dXJlKVxufVxuXG4vKipcbiAqIENvbWJpbmUgdiwgciwgYW5kIHMgcGFyYW1zIG9mIG11bHRpcGxlIHNpZ25hdHVyZXMgaW50byBmb3JtYXQgZXhwZWN0ZWQgYnkgY29udHJhY3RzXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZXMgVGhlIGxpc3Qgb2Ygc2lnbmF0dXJlcyB0byBjb21iaW5lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lT3JhY2xlU2lnbmF0dXJlcyhcbiAgc2lnbmF0dXJlczogUmVxdWlyZWQ8dXRpbHMuU2lnbmF0dXJlPltdLFxuKTogT3JhY2xlU2lnbmF0dXJlcyB7XG4gIHJldHVybiBzaWduYXR1cmVzLnJlZHVjZTxPcmFjbGVTaWduYXR1cmVzPihcbiAgICAocHJldiwgeyB2LCByLCBzIH0pID0+IHtcbiAgICAgIHByZXYudnMucHVzaCh2KVxuICAgICAgcHJldi5ycy5wdXNoKHIpXG4gICAgICBwcmV2LnNzLnB1c2gocylcblxuICAgICAgcmV0dXJuIHByZXZcbiAgICB9LFxuICAgIHsgdnM6IFtdLCByczogW10sIHNzOiBbXSB9LFxuICApXG59XG5cbmZ1bmN0aW9uIHNlcnZpY2VBZ3JlZW1lbnRWYWx1ZXMoc2E6IFNlcnZpY2VBZ3JlZW1lbnQpIHtcbiAgcmV0dXJuIFtcbiAgICBzYS5wYXltZW50LFxuICAgIHNhLmV4cGlyYXRpb24sXG4gICAgc2EuZW5kQXQsXG4gICAgc2Eub3JhY2xlcy5tYXAobyA9PiAobyBpbnN0YW5jZW9mIGV0aGVycy5XYWxsZXQgPyBvLmFkZHJlc3MgOiBvKSksXG4gICAgc2EucmVxdWVzdERpZ2VzdCxcbiAgICBzYS5hZ2dyZWdhdG9yLFxuICAgIHNhLmFnZ0luaXRpYXRlSm9iU2VsZWN0b3IsXG4gICAgc2EuYWdnRnVsZmlsbFNlbGVjdG9yLFxuICBdXG59XG4iXX0=