"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file provides convenience functions to interact with existing solidity contract abstraction libraries, such as
 * @truffle/contract and ethers.js specifically for our `Oracle.sol` solidity smart contract.
 */
const ethers_1 = require("ethers");
const debug_1 = require("../debug");
const helpers_1 = require("../helpers");
const debug = debug_1.makeDebug('oracle');
/**
 * Convert the javascript format of the parameters needed to call the
 * ```solidity
 *  function fulfillOracleRequest(
 *    bytes32 _requestId,
 *    uint256 _payment,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _expiration,
 *    bytes32 _data
 *  )
 * ```
 * method on an Oracle.sol contract.
 *
 * @param runRequest The run request to flatten into the correct order to perform the `fulfillOracleRequest` function
 * @param response The response to fulfill the run request with, if it is an ascii string, it is converted to bytes32 string
 * @param txOpts Additional ethereum tx options
 */
function convertFufillParams(runRequest, response, txOpts = {}) {
    const d = debug.extend('fulfillOracleRequestParams');
    d('Response param: %s', response);
    const bytes32Len = 32 * 2 + 2;
    const convertedResponse = response.length < bytes32Len
        ? ethers_1.ethers.utils.formatBytes32String(response)
        : response;
    d('Converted Response param: %s', convertedResponse);
    return [
        runRequest.requestId,
        runRequest.payment,
        runRequest.callbackAddr,
        runRequest.callbackFunc,
        runRequest.expiration,
        convertedResponse,
        txOpts,
    ];
}
exports.convertFufillParams = convertFufillParams;
/**
 * Convert the javascript format of the parameters needed to call the
 * ```solidity
 *  function cancelOracleRequest(
 *    bytes32 _requestId,
 *    uint256 _payment,
 *    bytes4 _callbackFunc,
 *    uint256 _expiration
 *  )
 * ```
 * method on an Oracle.sol contract.
 *
 * @param runRequest The run request to flatten into the correct order to perform the `cancelOracleRequest` function
 * @param txOpts Additional ethereum tx options
 */
function convertCancelParams(runRequest, txOpts = {}) {
    return [
        runRequest.requestId,
        runRequest.payment,
        runRequest.callbackFunc,
        runRequest.expiration,
        txOpts,
    ];
}
exports.convertCancelParams = convertCancelParams;
/**
 * Abi encode parameters to call the `oracleRequest` method on the [Oracle.sol](../../../evm/contracts/Oracle.sol) contract.
 * ```solidity
 *  function oracleRequest(
 *    address _sender,
 *    uint256 _payment,
 *    bytes32 _specId,
 *    address _callbackAddress,
 *    bytes4 _callbackFunctionId,
 *    uint256 _nonce,
 *    uint256 _dataVersion,
 *    bytes _data
 *  )
 * ```
 *
 * @param specId The Job Specification ID
 * @param callbackAddr The callback contract address for the response
 * @param callbackFunctionId The callback function id for the response
 * @param nonce The nonce sent by the requester
 * @param data The CBOR payload of the request
 */
function encodeOracleRequest(specId, callbackAddr, callbackFunctionId, nonce, data) {
    const oracleRequestSighash = '0x40429946';
    const oracleRequestInputs = [
        { name: '_sender', type: 'address' },
        { name: '_payment', type: 'uint256' },
        { name: '_specId', type: 'bytes32' },
        { name: '_callbackAddress', type: 'address' },
        { name: '_callbackFunctionId', type: 'bytes4' },
        { name: '_nonce', type: 'uint256' },
        { name: '_dataVersion', type: 'uint256' },
        { name: '_data', type: 'bytes' },
    ];
    const encodedParams = ethers_1.ethers.utils.defaultAbiCoder.encode(oracleRequestInputs.map(i => i.type), [
        ethers_1.ethers.constants.AddressZero,
        0,
        specId,
        callbackAddr,
        callbackFunctionId,
        nonce,
        1,
        data,
    ]);
    return `${oracleRequestSighash}${helpers_1.stripHexPrefix(encodedParams)}`;
}
exports.encodeOracleRequest = encodeOracleRequest;
/**
 * Extract a javascript representation of a run request from the data
 * contained within a EVM log.
 * ```solidity
 *  event OracleRequest(
 *    bytes32 indexed specId,
 *    address requester,
 *    bytes32 requestId,
 *    uint256 payment,
 *    address callbackAddr,
 *    bytes4 callbackFunctionId,
 *    uint256 cancelExpiration,
 *    uint256 dataVersion,
 *    bytes data
 *  );
 * ```
 *
 * @param log The log to extract the run request from
 */
function decodeRunRequest(log) {
    if (!log) {
        throw Error('No logs found to decode');
    }
    const ORACLE_REQUEST_TYPES = [
        'address',
        'bytes32',
        'uint256',
        'address',
        'bytes4',
        'uint256',
        'uint256',
        'bytes',
    ];
    const [requester, requestId, payment, callbackAddress, callbackFunc, expiration, version, data,] = ethers_1.ethers.utils.defaultAbiCoder.decode(ORACLE_REQUEST_TYPES, log.data);
    return {
        specId: log.topics[1],
        requester,
        requestId: helpers_1.toHex(requestId),
        payment: helpers_1.toHex(payment),
        callbackAddr: callbackAddress,
        callbackFunc: helpers_1.toHex(callbackFunc),
        expiration: helpers_1.toHex(expiration),
        data: helpers_1.addCBORMapDelimiters(Buffer.from(helpers_1.stripHexPrefix(data), 'hex')),
        dataVersion: version.toNumber(),
        topic: log.topics[0],
    };
}
exports.decodeRunRequest = decodeRunRequest;
/**
 * Extract a javascript representation of a ConcreteChainlinked#Request event
 * from an EVM log.
 * ```solidity
 *  event Request(
 *    bytes32 id,
 *    address callbackAddress,
 *    bytes4 callbackfunctionSelector,
 *    bytes data
 *  );
 * ```
 * The request event is emitted from the `ConcreteChainlinked.sol` testing contract.
 *
 * @param log The log to decode
 */
function decodeCCRequest(log) {
    const d = debug.extend('decodeRunABI');
    d('params %o', log);
    const REQUEST_TYPES = ['bytes32', 'address', 'bytes4', 'bytes'];
    const decodedValue = ethers_1.ethers.utils.defaultAbiCoder.decode(REQUEST_TYPES, log.data);
    d('decoded value %o', decodedValue);
    return decodedValue;
}
exports.decodeCCRequest = decodeCCRequest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JhY2xlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbnRyYWN0cy9vcmFjbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7R0FLRztBQUNILG1DQUErQjtBQUUvQixvQ0FBb0M7QUFDcEMsd0NBQXdFO0FBQ3hFLE1BQU0sS0FBSyxHQUFHLGlCQUFTLENBQUMsUUFBUSxDQUFDLENBQUE7QUEyRmpDOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUNILFNBQWdCLG1CQUFtQixDQUNqQyxVQUFzQixFQUN0QixRQUFnQixFQUNoQixTQUFvQixFQUFFO0lBRXRCLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsNEJBQTRCLENBQUMsQ0FBQTtJQUNwRCxDQUFDLENBQUMsb0JBQW9CLEVBQUUsUUFBUSxDQUFDLENBQUE7SUFFakMsTUFBTSxVQUFVLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDN0IsTUFBTSxpQkFBaUIsR0FDckIsUUFBUSxDQUFDLE1BQU0sR0FBRyxVQUFVO1FBQzFCLENBQUMsQ0FBQyxlQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQztRQUM1QyxDQUFDLENBQUMsUUFBUSxDQUFBO0lBQ2QsQ0FBQyxDQUFDLDhCQUE4QixFQUFFLGlCQUFpQixDQUFDLENBQUE7SUFFcEQsT0FBTztRQUNMLFVBQVUsQ0FBQyxTQUFTO1FBQ3BCLFVBQVUsQ0FBQyxPQUFPO1FBQ2xCLFVBQVUsQ0FBQyxZQUFZO1FBQ3ZCLFVBQVUsQ0FBQyxZQUFZO1FBQ3ZCLFVBQVUsQ0FBQyxVQUFVO1FBQ3JCLGlCQUFpQjtRQUNqQixNQUFNO0tBQ1AsQ0FBQTtBQUNILENBQUM7QUF4QkQsa0RBd0JDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0dBY0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FDakMsVUFBc0IsRUFDdEIsU0FBb0IsRUFBRTtJQUV0QixPQUFPO1FBQ0wsVUFBVSxD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UUFFL0IsS0FBSyxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQ3JCLENBQUE7QUFDSCxDQUFDO0FBdkNELDRDQXVDQztBQUVEOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsU0FBZ0IsZUFBZSxDQUM3QixHQUF5QjtJQUV6QixNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFBO0lBQ3RDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUE7SUFFbkIsTUFBTSxhQUFhLEdBQUcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUMvRCxNQUFNLFlBQVksR0FBRyxlQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQ3RELGFBQWEsRUFDYixHQUFHLENBQUMsSUFBSSxDQUNULENBQUE7SUFDRCxDQUFDLENBQUMsa0JBQWtCLEVBQUUsWUFBWSxDQUFDLENBQUE7SUFFbkMsT0FBTyxZQUFZLENBQUE7QUFDckIsQ0FBQztBQWRELDBDQWNDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgY29udmVuaWVuY2UgZnVuY3Rpb25zIHRvIGludGVyYWN0IHdpdGggZXhpc3Rpbmcgc29saWRpdHkgY29udHJhY3QgYWJzdHJhY3Rpb24gbGlicmFyaWVzLCBzdWNoIGFzXG4gKiBAdHJ1ZmZsZS9jb250cmFjdCBhbmQgZXRoZXJzLmpzIHNwZWNpZmljYWxseSBmb3Igb3VyIGBPcmFjbGUuc29sYCBzb2xpZGl0eSBzbWFydCBjb250cmFjdC5cbiAqL1xuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJ1xuaW1wb3J0IHsgQmlnTnVtYmVyaXNoIH0gZnJvbSAnZXRoZXJzL3V0aWxzJ1xuaW1wb3J0IHsgbWFrZURlYnVnIH0gZnJvbSAnLi4vZGVidWcnXG5pbXBvcnQgeyBhZGRDQk9STWFwRGVsaW1pdGVycywgc3RyaXBIZXhQcmVmaXgsIHRvSGV4IH0gZnJvbSAnLi4vaGVscGVycydcbmNvbnN0IGRlYnVnID0gbWFrZURlYnVnKCdvcmFjbGUnKVxuXG4vKipcbiAqIFRyYW5zYWN0aW9uIG9wdGlvbnMgc3VjaCBhcyBnYXNMaW1pdCwgZ2FzUHJpY2UsIGRhdGEsIC4uLlxuICovXG50eXBlIFR4T3B0aW9ucyA9IE9taXQ8ZXRoZXJzLnByb3ZpZGVycy5UcmFuc2FjdGlvblJlcXVlc3QsICd0bycgfCAnZnJvbSc+XG5cbi8qKlxuICogQSBydW4gcmVxdWVzdCBpcyBhbiBldmVudCBlbWl0dGVkIGJ5IGBPcmFjbGUuc29sYCB3aGljaCB0cmlnZ2VycyBhIGpvYiBydW5cbiAqIG9uIGEgcmVjZWl2aW5nIGNoYWlubGluayBub2RlIHdhdGNoaW5nIGZvciBSdW5SZXF1ZXN0cyBjb21pbmcgZnJvbSB0aGF0XG4gKiBzcGVjSWQgKyBvcHRpb25hbGx5IHJlcXVlc3Rlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW5SZXF1ZXN0IHtcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgam9iIHNwZWMgdGhpcyByZXF1ZXN0IGlzIHRhcmdldGluZ1xuICAgKlxuICAgKiBAc29sZm9ybWF0IGJ5dGVzMzJcbiAgICovXG4gIHNwZWNJZDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgcmVxdWVzdGVyIG9mIHRoZSBydW5cbiAgICpcbiAgICogQHNvbGZvcm1hdCBhZGRyZXNzXG4gICAqL1xuICByZXF1ZXN0ZXI6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSByZXF1ZXN0LCBjaGVjayBPcmFjbGUuc29sI29yYWNsZVJlcXVlc3QgdG8gc2VlIGhvdyBpdHMgY29tcHV0ZWRcbiAgICpcbiAgICogQHNvbGZvcm1hdCBieXRlczMyXG4gICAqL1xuICByZXF1ZXN0SWQ6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBMSU5LIHVzZWQgZm9yIHBheW1lbnRcbiAgICpcbiAgICogQHNvbGZvcm1hdCB1aW50MjU2XG4gICAqL1xuICBwYXltZW50OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCBpbnN0YW5jZSB0byBjYWxsYmFjayB3aXRoIHRoZSBmdWxmaWxsbWVudCByZXN1bHRcbiAgICpcbiAgICogQHNvbGZvcm1hdCBhZGRyZXNzXG4gICAqL1xuICBjYWxsYmFja0FkZHI6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHNlbGVjdG9yIG9mIHRoZSBtZXRob2QgdGhhdCB0aGUgb3JhY2xlIHNob3VsZCBjYWxsIGFmdGVyIGZ1bGZpbGxtZW50XG4gICAqXG4gICAqIEBzb2xmb3JtYXQgYnl0ZXM0XG4gICAqL1xuICBjYWxsYmFja0Z1bmM6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGV4cGlyYXRpb24gdGhhdCB0aGUgbm9kZSBzaG91bGQgcmVzcG9uZCBieSBiZWZvcmUgdGhlIHJlcXVlc3RlciBjYW4gY2FuY2VsXG4gICAqXG4gICAqIEBzb2xmb3JtYXQgdWludDI1NlxuICAgKi9cbiAgZXhwaXJhdGlvbjogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWVkIGRhdGEgdmVyc2lvblxuICAgKlxuICAgKiBAc29sZm9ybWF0IHVpbnQyNTZcbiAgICovXG4gIGRhdGFWZXJzaW9uOiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBDQk9SIGVuY29kZWQgcGF5bG9hZCBvZiB0aGUgcmVxdWVzdFxuICAgKlxuICAgKiBAc29sZm9ybWF0IGJ5dGVzXG4gICAqL1xuICBkYXRhOiBCdWZmZXJcblxuICAvKipcbiAgICogVGhlIGhhc2ggb2YgdGhlIHNpZ25hdHVyZSBvZiB0aGUgT3JhY2xlUmVxdWVzdCBldmVudC5cbiAgICogYGBgc29saWRpdHlcbiAgICogIGV2ZW50IE9yYWNsZVJlcXVlc3QoXG4gICAqICAgIGJ5dGVzMzIgaW5kZXhlZCBzcGVjSWQsXG4gICAqICAgIGFkZHJlc3MgcmVxdWVzdGVyLFxuICAgKiAgICBieXRlczMyIHJlcXVlc3RJZCxcbiAgICogICAgdWludDI1NiBwYXltZW50LFxuICAgKiAgICBhZGRyZXNzIGNhbGxiYWNrQWRkcixcbiAgICogICAgYnl0ZXM0IGNhbGxiYWNrRnVuY3Rpb25JZCxcbiAgICogICAgdWludDI1NiBjYW5jZWxFeHBpcmF0aW9uLFxuICAgKiAgICB1aW50MjU2IGRhdGFWZXJzaW9uLFxuICAgKiAgICBieXRlcyBkYXRhXG4gICAqICApO1xuICAgKiBgYGBcbiAgICogTm90ZTogdGhpcyBpcyBhIHByb3BlcnR5IHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cbiAgICogSXQgaXMgbm90IHBhcnQgb2YgdGhlIGFjdHVhbCBydW4gcmVxdWVzdC5cbiAgICpcbiAgICogQHNvbGZvcm1hdCBieXRlczMyXG4gICAqL1xuICB0b3BpYzogc3RyaW5nXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgamF2YXNjcmlwdCBmb3JtYXQgb2YgdGhlIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGNhbGwgdGhlXG4gKiBgYGBzb2xpZGl0eVxuICogIGZ1bmN0aW9uIGZ1bGZpbGxPcmFjbGVSZXF1ZXN0KFxuICogICAgYnl0ZXMzMiBfcmVxdWVzdElkLFxuICogICAgdWludDI1NiBfcGF5bWVudCxcbiAqICAgIGFkZHJlc3MgX2NhbGxiYWNrQWRkcmVzcyxcbiAqICAgIGJ5dGVzNCBfY2FsbGJhY2tGdW5jdGlvbklkLFxuICogICAgdWludDI1NiBfZXhwaXJhdGlvbixcbiAqICAgIGJ5dGVzMzIgX2RhdGFcbiAqICApXG4gKiBgYGBcbiAqIG1ldGhvZCBvbiBhbiBPcmFjbGUuc29sIGNvbnRyYWN0LlxuICpcbiAqIEBwYXJhbSBydW5SZXF1ZXN0IFRoZSBydW4gcmVxdWVzdCB0byBmbGF0dGVuIGludG8gdGhlIGNvcnJlY3Qgb3JkZXIgdG8gcGVyZm9ybSB0aGUgYGZ1bGZpbGxPcmFjbGVSZXF1ZXN0YCBmdW5jdGlvblxuICogQHBhcmFtIHJlc3BvbnNlIFRoZSByZXNwb25zZSB0byBmdWxmaWxsIHRoZSBydW4gcmVxdWVzdCB3aXRoLCBpZiBpdCBpcyBhbiBhc2NpaSBzdHJpbmcsIGl0IGlzIGNvbnZlcnRlZCB0byBieXRlczMyIHN0cmluZ1xuICogQHBhcmFtIHR4T3B0cyBBZGRpdGlvbmFsIGV0aGVyZXVtIHR4IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRGdWZpbGxQYXJhbXMoXG4gIHJ1blJlcXVlc3Q6IFJ1blJlcXVlc3QsXG4gIHJlc3BvbnNlOiBzdHJpbmcsXG4gIHR4T3B0czogVHhPcHRpb25zID0ge30sXG4pOiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgVHhPcHRpb25zXSB7XG4gIGNvbnN0IGQgPSBkZWJ1Zy5leHRlbmQoJ2Z1bGZpbGxPcmFjbGVSZXF1ZXN0UGFyYW1zJylcbiAgZCgnUmVzcG9uc2UgcGFyYW06ICVzJywgcmVzcG9uc2UpXG5cbiAgY29uc3QgYnl0ZXMzMkxlbiA9IDMyICogMiArIDJcbiAgY29uc3QgY29udmVydGVkUmVzcG9uc2UgPVxuICAgIHJlc3BvbnNlLmxlbmd0aCA8IGJ5dGVzMzJMZW5cbiAgICAgID8gZXRoZXJzLnV0aWxzLmZvcm1hdEJ5dGVzMzJTdHJpbmcocmVzcG9uc2UpXG4gICAgICA6IHJlc3BvbnNlXG4gIGQoJ0NvbnZlcnRlZCBSZXNwb25zZSBwYXJhbTogJXMnLCBjb252ZXJ0ZWRSZXNwb25zZSlcblxuICByZXR1cm4gW1xuICAgIHJ1blJlcXVlc3QucmVxdWVzdElkLFxuICAgIHJ1blJlcXVlc3QucGF5bWVudCxcbiAgICBydW5SZXF1ZXN0LmNhbGxiYWNrQWRkcixcbiAgICBydW5SZXF1ZXN0LmNhbGxiYWNrRnVuYyxcbiAgICBydW5SZXF1ZXN0LmV4cGlyYXRpb24sXG4gICAgY29udmVydGVkUmVzcG9uc2UsXG4gICAgdHhPcHRzLFxuICBdXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgamF2YXNjcmlwdCBmb3JtYXQgb2YgdGhlIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGNhbGwgdGhlXG4gKiBgYGBzb2xpZGl0eVxuICogIGZ1bmN0aW9uIGNhbmNlbE9yYWNsZVJlcXVlc3QoXG4gKiAgICBieXRlczMyIF9yZXF1ZXN0SWQsXG4gKiAgICB1aW50MjU2IF9wYXltZW50LFxuICogICAgYnl0ZXM0IF9jYWxsYmFja0Z1bmMsXG4gKiAgICB1aW50MjU2IF9leHBpcmF0aW9uXG4gKiAgKVxuICogYGBgXG4gKiBtZXRob2Qgb24gYW4gT3JhY2xlLnNvbCBjb250cmFjdC5cbiAqXG4gKiBAcGFyYW0gcnVuUmVxdWVzdCBUaGUgcnVuIHJlcXVlc3QgdG8gZmxhdHRlbiBpbnRvIHRoZSBjb3JyZWN0IG9yZGVyIHRvIHBlcmZvcm0gdGhlIGBjYW5jZWxPcmFjbGVSZXF1ZXN0YCBmdW5jdGlvblxuICogQHBhcmFtIHR4T3B0cyBBZGRpdGlvbmFsIGV0aGVyZXVtIHR4IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDYW5jZWxQYXJhbXMoXG4gIHJ1blJlcXVlc3Q6IFJ1blJlcXVlc3QsXG4gIHR4T3B0czogVHhPcHRpb25zID0ge30sXG4pOiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBUeE9wdGlvbnNdIHtcbiAgcmV0dXJuIFtcbiAgICBydW5SZXF1ZXN0LnJlcXVlc3RJZCxcbiAgICBydW5SZXF1ZXN0LnBheW1lbnQsXG4gICAgcnVuUmVxdWVzdC5jYWxsYmFja0Z1bmMsXG4gICAgcnVuUmVxdWVzdC5leHBpcmF0aW9uLFxuICAgIHR4T3B0cyxcbiAgXVxufVxuXG4vKipcbiAqIEFiaSBlbmNvZGUgcGFyYW1ldGVycyB0byBjYWxsIHRoZSBgb3JhY2xlUmVxdWVzdGAgbWV0aG9kIG9uIHRoZSBbT3JhY2xlLnNvbF0oLi4vLi4vLi4vZXZtL2NvbnRyYWN0cy9PcmFjbGUuc29sKSBjb250cmFjdC5cbiAqIGBgYHNvbGlkaXR5XG4gKiAgZnVuY3Rpb24gb3JhY2xlUmVxdWVzdChcbiAqICAgIGFkZHJlc3MgX3NlbmRlcixcbiAqICAgIHVpbnQyNTYgX3BheW1lbnQsXG4gKiAgICBieXRlczMyIF9zcGVjSWQsXG4gKiAgICBhZGRyZXNzIF9jYWxsYmFja0FkZHJlc3MsXG4gKiAgICBieXRlczQgX2NhbGxiYWNrRnVuY3Rpb25JZCxcbiAqICAgIHVpbnQyNTYgX25vbmNlLFxuICogICAgdWludDI1NiBfZGF0YVZlcnNpb24sXG4gKiAgICBieXRlcyBfZGF0YVxuICogIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzcGVjSWQgVGhlIEpvYiBTcGVjaWZpY2F0aW9uIElEXG4gKiBAcGFyYW0gY2FsbGJhY2tBZGRyIFRoZSBjYWxsYmFjayBjb250cmFjdCBhZGRyZXNzIGZvciB0aGUgcmVzcG9uc2VcbiAqIEBwYXJhbSBjYWxsYmFja0Z1bmN0aW9uSWQgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlkIGZvciB0aGUgcmVzcG9uc2VcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugc2VudCBieSB0aGUgcmVxdWVzdGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgQ0JPUiBwYXlsb2FkIG9mIHRoZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVPcmFjbGVSZXF1ZXN0KFxuICBzcGVjSWQ6IHN0cmluZyxcbiAgY2FsbGJhY2tBZGRyOiBzdHJpbmcsXG4gIGNhbGxiYWNrRnVuY3Rpb25JZDogc3RyaW5nLFxuICBub25jZTogbnVtYmVyLFxuICBkYXRhOiBCaWdOdW1iZXJpc2gsXG4pOiBzdHJpbmcge1xuICBjb25zdCBvcmFjbGVSZXF1ZXN0U2lnaGFzaCA9ICcweDQwNDI5OTQ2J1xuICBjb25zdCBvcmFjbGVSZXF1ZXN0SW5wdXRzID0gW1xuICAgIHsgbmFtZTogJ19zZW5kZXInLCB0eXBlOiAnYWRkcmVzcycgfSxcbiAgICB7IG5hbWU6ICdfcGF5bWVudCcsIHR5cGU6ICd1aW50MjU2JyB9LFxuICAgIHsgbmFtZTogJ19zcGVjSWQnLCB0eXBlOiAnYnl0ZXMzMicgfSxcbiAgICB7IG5hbWU6ICdfY2FsbGJhY2tBZGRyZXNzJywgdHlwZTogJ2FkZHJlc3MnIH0sXG4gICAgeyBuYW1lOiAnX2NhbGxiYWNrRnVuY3Rpb25JZCcsIHR5cGU6ICdieXRlczQnIH0sXG4gICAgeyBuYW1lOiAnX25vbmNlJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgeyBuYW1lOiAnX2RhdGFWZXJzaW9uJywgdHlwZTogJ3VpbnQyNTYnIH0sXG4gICAgeyBuYW1lOiAnX2RhdGEnLCB0eXBlOiAnYnl0ZXMnIH0sXG4gIF1cblxuICBjb25zdCBlbmNvZGVkUGFyYW1zID0gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5lbmNvZGUoXG4gICAgb3JhY2xlUmVxdWVzdElucHV0cy5tYXAoaSA9PiBpLnR5cGUpLFxuICAgIFtcbiAgICAgIGV0aGVycy5jb25zdGFudHMuQWRkcmVzc1plcm8sXG4gICAgICAwLFxuICAgICAgc3BlY0lkLFxuICAgICAgY2FsbGJhY2tBZGRyLFxuICAgICAgY2FsbGJhY2tGdW5jdGlvbklkLFxuICAgICAgbm9uY2UsXG4gICAgICAxLFxuICAgICAgZGF0YSxcbiAgICBdLFxuICApXG5cbiAgcmV0dXJuIGAke29yYWNsZVJlcXVlc3RTaWdoYXNofSR7c3RyaXBIZXhQcmVmaXgoZW5jb2RlZFBhcmFtcyl9YFxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGEgcnVuIHJlcXVlc3QgZnJvbSB0aGUgZGF0YVxuICogY29udGFpbmVkIHdpdGhpbiBhIEVWTSBsb2cuXG4gKiBgYGBzb2xpZGl0eVxuICogIGV2ZW50IE9yYWNsZVJlcXVlc3QoXG4gKiAgICBieXRlczMyIGluZGV4ZWQgc3BlY0lkLFxuICogICAgYWRkcmVzcyByZXF1ZXN0ZXIsXG4gKiAgICBieXRlczMyIHJlcXVlc3RJZCxcbiAqICAgIHVpbnQyNTYgcGF5bWVudCxcbiAqICAgIGFkZHJlc3MgY2FsbGJhY2tBZGRyLFxuICogICAgYnl0ZXM0IGNhbGxiYWNrRnVuY3Rpb25JZCxcbiAqICAgIHVpbnQyNTYgY2FuY2VsRXhwaXJhdGlvbixcbiAqICAgIHVpbnQyNTYgZGF0YVZlcnNpb24sXG4gKiAgICBieXRlcyBkYXRhXG4gKiAgKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsb2cgVGhlIGxvZyB0byBleHRyYWN0IHRoZSBydW4gcmVxdWVzdCBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSdW5SZXF1ZXN0KGxvZz86IGV0aGVycy5wcm92aWRlcnMuTG9nKTogUnVuUmVxdWVzdCB7XG4gIGlmICghbG9nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vIGxvZ3MgZm91bmQgdG8gZGVjb2RlJylcbiAgfVxuXG4gIGNvbnN0IE9SQUNMRV9SRVFVRVNUX1RZUEVTID0gW1xuICAgICdhZGRyZXNzJyxcbiAgICAnYnl0ZXMzMicsXG4gICAgJ3VpbnQyNTYnLFxuICAgICdhZGRyZXNzJyxcbiAgICAnYnl0ZXM0JyxcbiAgICAndWludDI1NicsXG4gICAgJ3VpbnQyNTYnLFxuICAgICdieXRlcycsXG4gIF1cbiAgY29uc3QgW1xuICAgIHJlcXVlc3RlcixcbiAgICByZXF1ZXN0SWQsXG4gICAgcGF5bWVudCxcbiAgICBjYWxsYmFja0FkZHJlc3MsXG4gICAgY2FsbGJhY2tGdW5jLFxuICAgIGV4cGlyYXRpb24sXG4gICAgdmVyc2lvbixcbiAgICBkYXRhLFxuICBdID0gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoT1JBQ0xFX1JFUVVFU1RfVFlQRVMsIGxvZy5kYXRhKVxuXG4gIHJldHVybiB7XG4gICAgc3BlY0lkOiBsb2cudG9waWNzWzFdLFxuICAgIHJlcXVlc3RlcixcbiAgICByZXF1ZXN0SWQ6IHRvSGV4KHJlcXVlc3RJZCksXG4gICAgcGF5bWVudDogdG9IZXgocGF5bWVudCksXG4gICAgY2FsbGJhY2tBZGRyOiBjYWxsYmFja0FkZHJlc3MsXG4gICAgY2FsbGJhY2tGdW5jOiB0b0hleChjYWxsYmFja0Z1bmMpLFxuICAgIGV4cGlyYXRpb246IHRvSGV4KGV4cGlyYXRpb24pLFxuICAgIGRhdGE6IGFkZENCT1JNYXBEZWxpbWl0ZXJzKEJ1ZmZlci5mcm9tKHN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4JykpLFxuICAgIGRhdGFWZXJzaW9uOiB2ZXJzaW9uLnRvTnVtYmVyKCksXG5cbiAgICB0b3BpYzogbG9nLnRvcGljc1swXSxcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGEgQ29uY3JldGVDaGFpbmxpbmtlZCNSZXF1ZXN0IGV2ZW50XG4gKiBmcm9tIGFuIEVWTSBsb2cuXG4gKiBgYGBzb2xpZGl0eVxuICogIGV2ZW50IFJlcXVlc3QoXG4gKiAgICBieXRlczMyIGlkLFxuICogICAgYWRkcmVzcyBjYWxsYmFja0FkZHJlc3MsXG4gKiAgICBieXRlczQgY2FsbGJhY2tmdW5jdGlvblNlbGVjdG9yLFxuICogICAgYnl0ZXMgZGF0YVxuICogICk7XG4gKiBgYGBcbiAqIFRoZSByZXF1ZXN0IGV2ZW50IGlzIGVtaXR0ZWQgZnJvbSB0aGUgYENvbmNyZXRlQ2hhaW5saW5rZWQuc29sYCB0ZXN0aW5nIGNvbnRyYWN0LlxuICpcbiAqIEBwYXJhbSBsb2cgVGhlIGxvZyB0byBkZWNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUNDUmVxdWVzdChcbiAgbG9nOiBldGhlcnMucHJvdmlkZXJzLkxvZyxcbik6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmddIHtcbiAgY29uc3QgZCA9IGRlYnVnLmV4dGVuZCgnZGVjb2RlUnVuQUJJJylcbiAgZCgncGFyYW1zICVvJywgbG9nKVxuXG4gIGNvbnN0IFJFUVVFU1RfVFlQRVMgPSBbJ2J5dGVzMzInLCAnYWRkcmVzcycsICdieXRlczQnLCAnYnl0ZXMnXVxuICBjb25zdCBkZWNvZGVkVmFsdWUgPSBldGhlcnMudXRpbHMuZGVmYXVsdEFiaUNvZGVyLmRlY29kZShcbiAgICBSRVFVRVNUX1RZUEVTLFxuICAgIGxvZy5kYXRhLFxuICApXG4gIGQoJ2RlY29kZWQgdmFsdWUgJW8nLCBkZWNvZGVkVmFsdWUpXG5cbiAgcmV0dXJuIGRlY29kZWRWYWx1ZVxufVxuIl19