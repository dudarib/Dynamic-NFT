"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * @packageDocumentation
 *
 * This file provides common utility functions to perform ethereum related tasks, like
 * data format manipulation of buffers and hex strings,
 * finding, accessing logs and events,
 * and increasing test evm time.
 */
const cbor_1 = tslib_1.__importDefault(require("cbor"));
const chai_1 = require("chai");
const ethers_1 = require("ethers");
/**
 * Parse out an evm word (32 bytes) into an address (20 bytes) representation
 *
 * @param hex The evm word in hex string format to parse the address
 * out of.
 */
function evmWordToAddress(hex) {
    if (!hex) {
        throw Error('Input not defined');
    }
    chai_1.assert.equal(hex.slice(0, 26), '0x000000000000000000000000');
    return ethers_1.utils.getAddress(hex.slice(26));
}
exports.evmWordToAddress = evmWordToAddress;
/**
 * Convert a number value to bytes32 format
 *
 * @param num The number value to convert to bytes32 format
 */
function numToBytes32(num) {
    const hexNum = ethers_1.utils.hexlify(num);
    const strippedNum = stripHexPrefix(hexNum);
    if (strippedNum.length > 32 * 2) {
        throw Error('Cannot convert number to bytes32 format, value is greater than maximum bytes32 value');
    }
    return addHexPrefix(strippedNum.padStart(32 * 2, '0'));
}
exports.numToBytes32 = numToBytes32;
/**
 * Convert a UTF-8 string into a bytes32 hex string representation
 *
 * The inverse function of [[parseBytes32String]]
 *
 * @param args The UTF-8 string representation to convert to a bytes32 hex string representation
 */
function toBytes32String(...args) {
    return ethers_1.utils.formatBytes32String(...args);
}
exports.toBytes32String = toBytes32String;
/**
 * Convert a bytes32 formatted hex string into its UTF-8 representation
 *
 * The inverse function of [[toBytes32String]].
 *
 * @param args The bytes32 hex string representation to convert to an UTF-8 representation
 */
function parseBytes32String(...args) {
    return ethers_1.utils.parseBytes32String(...args);
}
exports.parseBytes32String = parseBytes32String;
/**
 * Converts any number, BigNumber, hex string or Arrayish to a hex string.
 *
 * @param args Value to convert to a hex string
 */
function toHex(...args) {
    return ethers_1.utils.hexlify(...args);
}
exports.toHex = toHex;
/**
 * Create a buffer from a hex string
 *
 * @param hexstr The hex string to convert to a buffer
 */
function hexToBuf(hexstr) {
    return Buffer.from(stripHexPrefix(hexstr), 'hex');
}
exports.hexToBuf = hexToBuf;
/**
 * Convert an Ether value to a wei amount
 *
 * @param args Ether value to convert to an Ether amount
 */
function toWei(...args) {
    return ethers_1.utils.parseEther(...args);
}
exports.toWei = toWei;
/**
 * Convert a value to an ethers BigNum
 *
 * @param num Value to convert to a BigNum
 */
function bigNum(num) {
    return ethers_1.utils.bigNumberify(num);
}
exports.bigNum = bigNum;
/**
 * Convert a UTF-8 string into a bytearray
 *
 * @param args The values needed to convert a string into a bytearray
 */
function toUtf8Bytes(...args) {
    return ethers_1.utils.toUtf8Bytes(...args);
}
exports.toUtf8Bytes = toUtf8Bytes;
/**
 * Turn a [x,y] coordinate into an ethereum address
 *
 * @param pubkey The x,y coordinate to turn into an ethereum address
 */
function pubkeyToAddress(pubkey) {
    // transform the value according to what ethers expects as a value
    const concatResult = `0x04${pubkey
        .map(coord => coord.toHexString())
        .join('')
        .replace(/0x/gi, '')}`;
    return ethers_1.utils.computeAddress(concatResult);
}
exports.pubkeyToAddress = pubkeyToAddress;
/**
 * A wrapper function to make generated contracts compatible with truffle test suites.
 *
 * Note that the returned contract is an instance of ethers.Contract, not a @truffle/contract, so there are slight
 * api differences, though largely the same.
 *
 * @see https://docs.ethers.io/ethers.js/html/api-contract.html
 * @param contractFactory The ethers based contract factory to interop with
 * @param address The address to supply as the signer
 */
function create(contractFactory, address) {
    const web3Instance = global.web3;
    const provider = new ethers_1.ethers.providers.Web3Provider(web3Instance.currentProvider);
    const signer = provider.getSigner(address);
    const factory = new contractFactory(signer);
    return factory;
}
exports.create = create;
/**
 * Decodes a CBOR hex string, and adds opening and closing brackets to the CBOR if they are not present.
 *
 * @param hexstr The hex string to decode
 */
function decodeDietCBOR(hexstr) {
    const buf = hexToBuf(hexstr);
    return cbor_1.default.decodeFirstSync(addCBORMapDelimiters(buf));
}
exports.decodeDietCBOR = decodeDietCBOR;
/**
 * Add a starting and closing map characters to a CBOR encoding if they are not already present.
 */
function addCBORMapDelimiters(buffer) {
    if (buffer[0] >> 5 === 5) {
        return buffer;
    }
    /**
     * This is the opening character of a CBOR map.
     * @see https://en.wikipedia.org/wiki/CBOR#CBOR_data_item_header
     */
    const startIndefiniteLengthMap = Buffer.from([0xbf]);
    /**
     * This is the closing character in a CBOR map.
     * @see https://en.wikipedia.org/wiki/CBOR#CBOR_data_item_header
     */
    const endIndefiniteLengthMap = Buffer.from([0xff]);
    return Buffer.concat([startIndefiniteLengthMap, buffer, endIndefiniteLengthMap], buffer.length + 2);
}
exports.addCBORMapDelimiters = addCBORMapDelimiters;
/**
 * Add a hex prefix to a hex string
 *
 * @param hex The hex string to prepend the hex prefix to
 */
function addHexPrefix(hex) {
    return hex.startsWith('0x') ? hex : `0x${hex}`;
}
exports.addHexPrefix = addHexPrefix;
/**
 * Strip the leading 0x hex prefix from a hex string
 *
 * @param hex The hex string to strip the leading hex prefix out of
 */
function stripHexPrefix(hex) {
    if (!ethers_1.ethers.utils.isHexString(hex)) {
        throw Error(`Expected valid hex string, got: "${hex}"`);
    }
    return hex.replace('0x', '');
}
exports.stripHexPrefix = stripHexPrefix;
/**
 * Compute the keccak256 cryptographic hash of a value, returned as a hex string.
 * (Note: often Ethereum documentation refers to this, incorrectly, as SHA3)
 *
 * @param args The data to compute the keccak256 hash of
 */
function keccak(...args) {
    return ethers_1.utils.keccak256(...args);
}
exports.keccak = keccak;
/**
 * Increase the current time within the evm to "n" seconds past the current time
 *
 * @param seconds The number of seconds to increase to the current time by
 * @param provider The ethers provider to send the time increase request to
 */
async function increaseTimeBy(seconds, provider) {
    await provider.send('evm_increaseTime', [seconds]);
}
exports.increaseTimeBy = increaseTimeBy;
/**
 * Instruct the provider to mine an additional block
 *
 * @param provider The ethers provider to instruct to mine an additional block
 */
async function mineBlock(provider) {
    await provider.send('evm_mine', []);
}
exports.mineBlock = mineBlock;
/**
 * Increase the current time within the evm to 5 minutes past the current time
 *
 * @param provider The ethers provider to send the time increase request to
 */
async function increaseTime5Minutes(provider) {
    await increaseTimeBy(5 * 600, provider);
}
exports.increaseTime5Minutes = increaseTime5Minutes;
/**
 * Typecast an ethers event to its proper type, until
 * https://github.com/ethers-io/ethers.js/pull/698 is addressed
 *
 * @param event The event to typecast
 */
function eventArgs(event) {
    var _a;
    return (_a = event) === null || _a === void 0 ? void 0 : _a.args;
}
exports.eventArgs = eventArgs;
/**
 * Find an event within a transaction receipt by its event description
 *
 * @param receipt The events array to search through
 * @param eventDescription The event description to pass to check its name by
 */
function findEventIn(receipt, eventDescription) {
    var _a;
    // the first topic of a log is always the keccak-256 hash of the event signature
    const event = (_a = receipt.events) === null || _a === void 0 ? void 0 : _a.find(e => e.topics[0] === eventDescription.topic);
    return event;
}
exports.findEventIn = findEventIn;
/**
 * Calculate six months from the current date in seconds
 */
function sixMonthsFromNow() {
    return ethers_1.utils.bigNumberify(Math.round(Date.now() / 1000.0) + 6 * 30 * 24 * 60 * 60);
}
exports.sixMonthsFromNow = sixMonthsFromNow;
/**
 * Extract array of logs from a transaction
 *
 * @param tx The transaction to wait for, then extract logs from
 */
async function getLogs(tx) {
    const receipt = await tx.wait();
    if (!receipt.logs) {
        throw Error('unable to extract logs from transaction receipt');
    }
    return receipt.logs;
}
exports.getLogs = getLogs;
/**
 * Retrieve single log from transaction
 *
 * @param tx The transaction to wait for, then extract logs from
 * @param index The index of the log to retrieve
 */
async function getLog(tx, index) {
    const logs = await getLogs(tx);
    if (!logs[index]) {
        throw Error('unable to extract log from transaction receipt');
    }
    return logs[index];
}
exports.getLog = getLog;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7Ozs7O0dBT0c7QUFDSCx3REFBdUI7QUFDdkIsK0JBQTZCO0FBQzdCLG1DQUFzQztBQUl0Qzs7Ozs7R0FLRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLEdBQVk7SUFDM0MsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7S0FDakM7SUFFRCxhQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLDRCQUE0QixDQUFDLENBQUE7SUFDNUQsT0FBTyxjQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUN4QyxDQUFDO0FBUEQsNENBT0M7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLEdBQXdDO0lBQ25FLE1BQU0sTUFBTSxHQUFHLGNBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDakMsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQzFDLElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFO1FBQy9CLE1BQU0sS0FBSyxDQUNULHNGQUFzRixDQUN2RixDQUFBO0tBQ0Y7SUFDRCxPQUFPLFlBQVksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQTtBQUN4RCxDQUFDO0FBVEQsb0NBU0M7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixlQUFlLENBQzdCLEdBQUcsSUFBa0Q7SUFFckQsT0FBTyxjQUFLLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQTtBQUMz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QUM7QUFSRCwwQkFRQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLE1BQU0sQ0FDMUIsRUFBOEIsRUFDOUIsS0FBYTtJQUViLE1BQU0sSUFBSSxHQUFHLE1BQU0sT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDaEIsTUFBTSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQTtLQUM5RDtJQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ3BCLENBQUM7QUFURCx3QkFTQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIGNvbW1vbiB1dGlsaXR5IGZ1bmN0aW9ucyB0byBwZXJmb3JtIGV0aGVyZXVtIHJlbGF0ZWQgdGFza3MsIGxpa2VcbiAqIGRhdGEgZm9ybWF0IG1hbmlwdWxhdGlvbiBvZiBidWZmZXJzIGFuZCBoZXggc3RyaW5ncyxcbiAqIGZpbmRpbmcsIGFjY2Vzc2luZyBsb2dzIGFuZCBldmVudHMsXG4gKiBhbmQgaW5jcmVhc2luZyB0ZXN0IGV2bSB0aW1lLlxuICovXG5pbXBvcnQgY2JvciBmcm9tICdjYm9yJ1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnY2hhaSdcbmltcG9ydCB7IGV0aGVycywgdXRpbHMgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgeyBDb250cmFjdFJlY2VpcHQgfSBmcm9tICdldGhlcnMvY29udHJhY3QnXG5pbXBvcnQgeyBFdmVudERlc2NyaXB0aW9uIH0gZnJvbSAnZXRoZXJzL3V0aWxzJ1xuXG4vKipcbiAqIFBhcnNlIG91dCBhbiBldm0gd29yZCAoMzIgYnl0ZXMpIGludG8gYW4gYWRkcmVzcyAoMjAgYnl0ZXMpIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIGhleCBUaGUgZXZtIHdvcmQgaW4gaGV4IHN0cmluZyBmb3JtYXQgdG8gcGFyc2UgdGhlIGFkZHJlc3NcbiAqIG91dCBvZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2bVdvcmRUb0FkZHJlc3MoaGV4Pzogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFoZXgpIHtcbiAgICB0aHJvdyBFcnJvcignSW5wdXQgbm90IGRlZmluZWQnKVxuICB9XG5cbiAgYXNzZXJ0LmVxdWFsKGhleC5zbGljZSgwLCAyNiksICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpXG4gIHJldHVybiB1dGlscy5nZXRBZGRyZXNzKGhleC5zbGljZSgyNikpXG59XG5cbi8qKlxuICogQ29udmVydCBhIG51bWJlciB2YWx1ZSB0byBieXRlczMyIGZvcm1hdFxuICpcbiAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB2YWx1ZSB0byBjb252ZXJ0IHRvIGJ5dGVzMzIgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudW1Ub0J5dGVzMzIobnVtOiBQYXJhbWV0ZXJzPHR5cGVvZiB1dGlscy5oZXhsaWZ5PlswXSk6IHN0cmluZyB7XG4gIGNvbnN0IGhleE51bSA9IHV0aWxzLmhleGxpZnkobnVtKVxuICBjb25zdCBzdHJpcHBlZE51bSA9IHN0cmlwSGV4UHJlZml4KGhleE51bSlcbiAgaWYgKHN0cmlwcGVkTnVtLmxlbmd0aCA+IDMyICogMikge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBjb252ZXJ0IG51bWJlciB0byBieXRlczMyIGZvcm1hdCwgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG1heGltdW0gYnl0ZXMzMiB2YWx1ZScsXG4gICAgKVxuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RyaXBwZWROdW0ucGFkU3RhcnQoMzIgKiAyLCAnMCcpKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBVVEYtOCBzdHJpbmcgaW50byBhIGJ5dGVzMzIgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvblxuICpcbiAqIFRoZSBpbnZlcnNlIGZ1bmN0aW9uIG9mIFtbcGFyc2VCeXRlczMyU3RyaW5nXV1cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgVVRGLTggc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGNvbnZlcnQgdG8gYSBieXRlczMyIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMzMlN0cmluZyhcbiAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgdXRpbHMuZm9ybWF0Qnl0ZXMzMlN0cmluZz5cbik6IFJldHVyblR5cGU8dHlwZW9mIHV0aWxzLmZvcm1hdEJ5dGVzMzJTdHJpbmc+IHtcbiAgcmV0dXJuIHV0aWxzLmZvcm1hdEJ5dGVzMzJTdHJpbmcoLi4uYXJncylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZXMzMiBmb3JtYXR0ZWQgaGV4IHN0cmluZyBpbnRvIGl0cyBVVEYtOCByZXByZXNlbnRhdGlvblxuICpcbiAqIFRoZSBpbnZlcnNlIGZ1bmN0aW9uIG9mIFtbdG9CeXRlczMyU3RyaW5nXV0uXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIGJ5dGVzMzIgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBjb252ZXJ0IHRvIGFuIFVURi04IHJlcHJlc2VudGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJ5dGVzMzJTdHJpbmcoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHV0aWxzLnBhcnNlQnl0ZXMzMlN0cmluZz5cbik6IFJldHVyblR5cGU8dHlwZW9mIHV0aWxzLnBhcnNlQnl0ZXMzMlN0cmluZz4ge1xuICByZXR1cm4gdXRpbHMucGFyc2VCeXRlczMyU3RyaW5nKC4uLmFyZ3MpXG59XG5cbi8qKlxuICogQ29udmVydHMgYW55IG51bWJlciwgQmlnTnVtYmVyLCBoZXggc3RyaW5nIG9yIEFycmF5aXNoIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYXJncyBWYWx1ZSB0byBjb252ZXJ0IHRvIGEgaGV4IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHV0aWxzLmhleGxpZnk+XG4pOiBSZXR1cm5UeXBlPHR5cGVvZiB1dGlscy5oZXhsaWZ5PiB7XG4gIHJldHVybiB1dGlscy5oZXhsaWZ5KC4uLmFyZ3MpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYnVmZmVyIGZyb20gYSBoZXggc3RyaW5nXG4gKlxuICogQHBhcmFtIGhleHN0ciBUaGUgaGV4IHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J1ZihoZXhzdHI6IHN0cmluZyk6IEJ1ZmZlciB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChoZXhzdHIpLCAnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEV0aGVyIHZhbHVlIHRvIGEgd2VpIGFtb3VudFxuICpcbiAqIEBwYXJhbSBhcmdzIEV0aGVyIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gRXRoZXIgYW1vdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1dlaShcbiAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgdXRpbHMucGFyc2VFdGhlcj5cbik6IFJldHVyblR5cGU8dHlwZW9mIHV0aWxzLnBhcnNlRXRoZXI+IHtcbiAgcmV0dXJuIHV0aWxzLnBhcnNlRXRoZXIoLi4uYXJncylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYW4gZXRoZXJzIEJpZ051bVxuICpcbiAqIEBwYXJhbSBudW0gVmFsdWUgdG8gY29udmVydCB0byBhIEJpZ051bVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmlnTnVtKG51bTogdXRpbHMuQmlnTnVtYmVyaXNoKTogdXRpbHMuQmlnTnVtYmVyIHtcbiAgcmV0dXJuIHV0aWxzLmJpZ051bWJlcmlmeShudW0pXG59XG5cbi8qKlxuICogQ29udmVydCBhIFVURi04IHN0cmluZyBpbnRvIGEgYnl0ZWFycmF5XG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIHZhbHVlcyBuZWVkZWQgdG8gY29udmVydCBhIHN0cmluZyBpbnRvIGEgYnl0ZWFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhCeXRlcyhcbiAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgdXRpbHMudG9VdGY4Qnl0ZXM+XG4pOiBSZXR1cm5UeXBlPHR5cGVvZiB1dGlscy50b1V0ZjhCeXRlcz4ge1xuICByZXR1cm4gdXRpbHMudG9VdGY4Qnl0ZXMoLi4uYXJncylcbn1cblxuLyoqXG4gKiBUdXJuIGEgW3gseV0gY29vcmRpbmF0ZSBpbnRvIGFuIGV0aGVyZXVtIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0gcHVia2V5IFRoZSB4LHkgY29vcmRpbmF0ZSB0byB0dXJuIGludG8gYW4gZXRoZXJldW0gYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHVia2V5VG9BZGRyZXNzKHB1YmtleTogdXRpbHMuQmlnTnVtYmVyW10pIHtcbiAgLy8gdHJhbnNmb3JtIHRoZSB2YWx1ZSBhY2NvcmRpbmcgdG8gd2hhdCBldGhlcnMgZXhwZWN0cyBhcyBhIHZhbHVlXG4gIGNvbnN0IGNvbmNhdFJlc3VsdCA9IGAweDA0JHtwdWJrZXlcbiAgICAubWFwKGNvb3JkID0+IGNvb3JkLnRvSGV4U3RyaW5nKCkpXG4gICAgLmpvaW4oJycpXG4gICAgLnJlcGxhY2UoLzB4L2dpLCAnJyl9YFxuXG4gIHJldHVybiB1dGlscy5jb21wdXRlQWRkcmVzcyhjb25jYXRSZXN1bHQpXG59XG5cbi8qKlxuICogQSB3cmFwcGVyIGZ1bmN0aW9uIHRvIG1ha2UgZ2VuZXJhdGVkIGNvbnRyYWN0cyBjb21wYXRpYmxlIHdpdGggdHJ1ZmZsZSB0ZXN0IHN1aXRlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHJldHVybmVkIGNvbnRyYWN0IGlzIGFuIGluc3RhbmNlIG9mIGV0aGVycy5Db250cmFjdCwgbm90IGEgQHRydWZmbGUvY29udHJhY3QsIHNvIHRoZXJlIGFyZSBzbGlnaHRcbiAqIGFwaSBkaWZmZXJlbmNlcywgdGhvdWdoIGxhcmdlbHkgdGhlIHNhbWUuXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MuZXRoZXJzLmlvL2V0aGVycy5qcy9odG1sL2FwaS1jb250cmFjdC5odG1sXG4gKiBAcGFyYW0gY29udHJhY3RGYWN0b3J5IFRoZSBldGhlcnMgYmFzZWQgY29udHJhY3QgZmFjdG9yeSB0byBpbnRlcm9wIHdpdGhcbiAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIHN1cHBseSBhcyB0aGUgc2lnbmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGU8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGNvbnRyYWN0RmFjdG9yeTogVCxcbiAgYWRkcmVzczogc3RyaW5nLFxuKTogSW5zdGFuY2VUeXBlPFQ+IHtcbiAgY29uc3Qgd2ViM0luc3RhbmNlID0gKGdsb2JhbCBhcyBhbnkpLndlYjNcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoXG4gICAgd2ViM0luc3RhbmNlLmN1cnJlbnRQcm92aWRlcixcbiAgKVxuICBjb25zdCBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoYWRkcmVzcylcbiAgY29uc3QgZmFjdG9yeSA9IG5ldyBjb250cmFjdEZhY3Rvcnkoc2lnbmVyKVxuXG4gIHJldHVybiBmYWN0b3J5XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIENCT1IgaGV4IHN0cmluZywgYW5kIGFkZHMgb3BlbmluZyBhbmQgY2xvc2luZyBicmFja2V0cyB0byB0aGUgQ0JPUiBpZiB0aGV5IGFyZSBub3QgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0gaGV4c3RyIFRoZSBoZXggc3RyaW5nIHRvIGRlY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGlldENCT1IoaGV4c3RyOiBzdHJpbmcpIHtcbiAgY29uc3QgYnVmID0gaGV4VG9CdWYoaGV4c3RyKVxuXG4gIHJldHVybiBjYm9yLmRlY29kZUZpcnN0U3luYyhhZGRDQk9STWFwRGVsaW1pdGVycyhidWYpKVxufVxuXG4vKipcbiAqIEFkZCBhIHN0YXJ0aW5nIGFuZCBjbG9zaW5nIG1hcCBjaGFyYWN0ZXJzIHRvIGEgQ0JPUiBlbmNvZGluZyBpZiB0aGV5IGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ0JPUk1hcERlbGltaXRlcnMoYnVmZmVyOiBCdWZmZXIpOiBCdWZmZXIge1xuICBpZiAoYnVmZmVyWzBdID4+IDUgPT09IDUpIHtcbiAgICByZXR1cm4gYnVmZmVyXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgb3BlbmluZyBjaGFyYWN0ZXIgb2YgYSBDQk9SIG1hcC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DQk9SI0NCT1JfZGF0YV9pdGVtX2hlYWRlclxuICAgKi9cbiAgY29uc3Qgc3RhcnRJbmRlZmluaXRlTGVuZ3RoTWFwID0gQnVmZmVyLmZyb20oWzB4YmZdKVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgY2xvc2luZyBjaGFyYWN0ZXIgaW4gYSBDQk9SIG1hcC5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DQk9SI0NCT1JfZGF0YV9pdGVtX2hlYWRlclxuICAgKi9cbiAgY29uc3QgZW5kSW5kZWZpbml0ZUxlbmd0aE1hcCA9IEJ1ZmZlci5mcm9tKFsweGZmXSlcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoXG4gICAgW3N0YXJ0SW5kZWZpbml0ZUxlbmd0aE1hcCwgYnVmZmVyLCBlbmRJbmRlZmluaXRlTGVuZ3RoTWFwXSxcbiAgICBidWZmZXIubGVuZ3RoICsgMixcbiAgKVxufVxuXG4vKipcbiAqIEFkZCBhIGhleCBwcmVmaXggdG8gYSBoZXggc3RyaW5nXG4gKlxuICogQHBhcmFtIGhleCBUaGUgaGV4IHN0cmluZyB0byBwcmVwZW5kIHRoZSBoZXggcHJlZml4IHRvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRIZXhQcmVmaXgoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gaGV4LnN0YXJ0c1dpdGgoJzB4JykgPyBoZXggOiBgMHgke2hleH1gXG59XG5cbi8qKlxuICogU3RyaXAgdGhlIGxlYWRpbmcgMHggaGV4IHByZWZpeCBmcm9tIGEgaGV4IHN0cmluZ1xuICpcbiAqIEBwYXJhbSBoZXggVGhlIGhleCBzdHJpbmcgdG8gc3RyaXAgdGhlIGxlYWRpbmcgaGV4IHByZWZpeCBvdXQgb2ZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KGhleDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFldGhlcnMudXRpbHMuaXNIZXhTdHJpbmcoaGV4KSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBoZXggc3RyaW5nLCBnb3Q6IFwiJHtoZXh9XCJgKVxuICB9XG5cbiAgcmV0dXJuIGhleC5yZXBsYWNlKCcweCcsICcnKVxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGtlY2NhazI1NiBjcnlwdG9ncmFwaGljIGhhc2ggb2YgYSB2YWx1ZSwgcmV0dXJuZWQgYXMgYSBoZXggc3RyaW5nLlxuICogKE5vdGU6IG9mdGVuIEV0aGVyZXVtIGRvY3VtZW50YXRpb24gcmVmZXJzIHRvIHRoaXMsIGluY29ycmVjdGx5LCBhcyBTSEEzKVxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBkYXRhIHRvIGNvbXB1dGUgdGhlIGtlY2NhazI1NiBoYXNoIG9mXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsoXG4gIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHV0aWxzLmtlY2NhazI1Nj5cbik6IFJldHVyblR5cGU8dHlwZW9mIHV0aWxzLmtlY2NhazI1Nj4ge1xuICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KC4uLmFyZ3MpXG59XG5cbi8qKlxuICogSW5jcmVhc2UgdGhlIGN1cnJlbnQgdGltZSB3aXRoaW4gdGhlIGV2bSB0byBcIm5cIiBzZWNvbmRzIHBhc3QgdGhlIGN1cnJlbnQgdGltZVxuICpcbiAqIEBwYXJhbSBzZWNvbmRzIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBpbmNyZWFzZSB0byB0aGUgY3VycmVudCB0aW1lIGJ5XG4gKiBAcGFyYW0gcHJvdmlkZXIgVGhlIGV0aGVycyBwcm92aWRlciB0byBzZW5kIHRoZSB0aW1lIGluY3JlYXNlIHJlcXVlc3QgdG9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlYXNlVGltZUJ5KFxuICBzZWNvbmRzOiBudW1iZXIsXG4gIHByb3ZpZGVyOiBldGhlcnMucHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcixcbikge1xuICBhd2FpdCBwcm92aWRlci5zZW5kKCdldm1faW5jcmVhc2VUaW1lJywgW3NlY29uZHNdKVxufVxuXG4vKipcbiAqIEluc3RydWN0IHRoZSBwcm92aWRlciB0byBtaW5lIGFuIGFkZGl0aW9uYWwgYmxvY2tcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgVGhlIGV0aGVycyBwcm92aWRlciB0byBpbnN0cnVjdCB0byBtaW5lIGFuIGFkZGl0aW9uYWwgYmxvY2tcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pbmVCbG9jayhwcm92aWRlcjogZXRoZXJzLnByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIpIHtcbiAgYXdhaXQgcHJvdmlkZXIuc2VuZCgnZXZtX21pbmUnLCBbXSlcbn1cblxuLyoqXG4gKiBJbmNyZWFzZSB0aGUgY3VycmVudCB0aW1lIHdpdGhpbiB0aGUgZXZtIHRvIDUgbWludXRlcyBwYXN0IHRoZSBjdXJyZW50IHRpbWVcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgVGhlIGV0aGVycyBwcm92aWRlciB0byBzZW5kIHRoZSB0aW1lIGluY3JlYXNlIHJlcXVlc3QgdG9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlYXNlVGltZTVNaW51dGVzKFxuICBwcm92aWRlcjogZXRoZXJzLnByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgaW5jcmVhc2VUaW1lQnkoNSAqIDYwMCwgcHJvdmlkZXIpXG59XG5cbmludGVyZmFjZSBFdmVudEFyZ3NBcnJheSBleHRlbmRzIEFycmF5PGFueT4ge1xuICBba2V5OiBzdHJpbmddOiBhbnlcbn1cbi8qKlxuICogVHlwZWNhc3QgYW4gZXRoZXJzIGV2ZW50IHRvIGl0cyBwcm9wZXIgdHlwZSwgdW50aWxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL3B1bGwvNjk4IGlzIGFkZHJlc3NlZFxuICpcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gdHlwZWNhc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50QXJncyhldmVudD86IGV0aGVycy5FdmVudCkge1xuICByZXR1cm4gKGV2ZW50Py5hcmdzIGFzIGFueSkgYXMgRXZlbnRBcmdzQXJyYXlcbn1cblxuLyoqXG4gKiBGaW5kIGFuIGV2ZW50IHdpdGhpbiBhIHRyYW5zYWN0aW9uIHJlY2VpcHQgYnkgaXRzIGV2ZW50IGRlc2NyaXB0aW9uXG4gKlxuICogQHBhcmFtIHJlY2VpcHQgVGhlIGV2ZW50cyBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIGV2ZW50RGVzY3JpcHRpb24gVGhlIGV2ZW50IGRlc2NyaXB0aW9uIHRvIHBhc3MgdG8gY2hlY2sgaXRzIG5hbWUgYnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFdmVudEluKFxuICByZWNlaXB0OiBDb250cmFjdFJlY2VpcHQsXG4gIGV2ZW50RGVzY3JpcHRpb246IEV2ZW50RGVzY3JpcHRpb24sXG4pOiBldGhlcnMuRXZlbnQgfCB1bmRlZmluZWQge1xuICAvLyB0aGUgZmlyc3QgdG9waWMgb2YgYSBsb2cgaXMgYWx3YXlzIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgdGhlIGV2ZW50IHNpZ25hdHVyZVxuICBjb25zdCBldmVudCA9IHJlY2VpcHQuZXZlbnRzPy5maW5kKFxuICAgIGUgPT4gZS50b3BpY3NbMF0gPT09IGV2ZW50RGVzY3JpcHRpb24udG9waWMsXG4gIClcblxuICByZXR1cm4gZXZlbnRcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgc2l4IG1vbnRocyBmcm9tIHRoZSBjdXJyZW50IGRhdGUgaW4gc2Vjb25kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2l4TW9udGhzRnJvbU5vdygpOiB1dGlscy5CaWdOdW1iZXIge1xuICByZXR1cm4gdXRpbHMuYmlnTnVtYmVyaWZ5KFxuICAgIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDAuMCkgKyA2ICogMzAgKiAyNCAqIDYwICogNjAsXG4gIClcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGFycmF5IG9mIGxvZ3MgZnJvbSBhIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHR4IFRoZSB0cmFuc2FjdGlvbiB0byB3YWl0IGZvciwgdGhlbiBleHRyYWN0IGxvZ3MgZnJvbVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TG9ncyhcbiAgdHg6IGV0aGVycy5Db250cmFjdFRyYW5zYWN0aW9uLFxuKTogUHJvbWlzZTxldGhlcnMucHJvdmlkZXJzLkxvZ1tdPiB7XG4gIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KClcbiAgaWYgKCFyZWNlaXB0LmxvZ3MpIHtcbiAgICB0aHJvdyBFcnJvcigndW5hYmxlIHRvIGV4dHJhY3QgbG9ncyBmcm9tIHRyYW5zYWN0aW9uIHJlY2VpcHQnKVxuICB9XG4gIHJldHVybiByZWNlaXB0LmxvZ3Ncbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBzaW5nbGUgbG9nIGZyb20gdHJhbnNhY3Rpb25cbiAqXG4gKiBAcGFyYW0gdHggVGhlIHRyYW5zYWN0aW9uIHRvIHdhaXQgZm9yLCB0aGVuIGV4dHJhY3QgbG9ncyBmcm9tXG4gKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBsb2cgdG8gcmV0cmlldmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExvZyhcbiAgdHg6IGV0aGVycy5Db250cmFjdFRyYW5zYWN0aW9uLFxuICBpbmRleDogbnVtYmVyLFxuKTogUHJvbWlzZTxldGhlcnMucHJvdmlkZXJzLkxvZz4ge1xuICBjb25zdCBsb2dzID0gYXdhaXQgZ2V0TG9ncyh0eClcbiAgaWYgKCFsb2dzW2luZGV4XSkge1xuICAgIHRocm93IEVycm9yKCd1bmFibGUgdG8gZXh0cmFjdCBsb2cgZnJvbSB0cmFuc2FjdGlvbiByZWNlaXB0JylcbiAgfVxuICByZXR1cm4gbG9nc1tpbmRleF1cbn1cbiJdfQ==