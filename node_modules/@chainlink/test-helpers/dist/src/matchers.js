"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file contains a number of matcher functions meant to perform common assertions for
 * ethereum based tests. Specific assertion functions targeting chainlink smart contracts live in
 * their respective contracts/<contract>.ts file.
 */
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const debug_1 = require("./debug");
const helpers_1 = require("./helpers");
const debug = debug_1.makeDebug('helpers');
/**
 * Check that two big numbers are the same value.
 *
 * @param expected The expected value to match against
 * @param actual The actual value to match against the expected value
 * @param failureMessage Failure message to display if the actual value does not match the expected value.
 */
function bigNum(expected, actual, failureMessage) {
    const msg = failureMessage ? ': ' + failureMessage : '';
    chai_1.assert(ethers_1.ethers.utils.bigNumberify(expected).eq(ethers_1.ethers.utils.bigNumberify(actual)), `BigNum (expected)${expected} is not (actual)${actual} ${msg}`);
}
exports.bigNum = bigNum;
/**
 * Check that an evm operation reverts
 *
 * @param action The asynchronous action to execute, which should cause an evm revert.
 * @param msg The failure message to display if the action __does not__ throw
 */
async function evmRevert(action, msg) {
    const d = debug.extend('assertActionThrows');
    let e = undefined;
    try {
        if (typeof action === 'function') {
            await action();
        }
        else {
            await action;
        }
    }
    catch (error) {
        e = error;
    }
    d(e);
    if (!e) {
        chai_1.assert.exists(e, 'Expected an error to be raised');
        return;
    }
    chai_1.assert(e.message, 'Expected an error to contain a message');
    const ERROR_MESSAGES = ['invalid opcode', 'revert'];
    const hasErrored = ERROR_MESSAGES.some(msg => { var _a, _b; return (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(msg); });
    if (msg) {
        expect(e.message).toMatch(msg);
    }
    chai_1.assert(hasErrored, `expected following error message to include ${ERROR_MESSAGES.join(' or ')}. Got: "${e.message}"`);
}
exports.evmRevert = evmRevert;
/**
 * Check that a contract's abi exposes the expected interface.
 *
 * @param contract The contract with the actual abi to check the expected exposed methods and getters against.
 * @param expectedPublic The expected public exposed methods and getters to match against the actual abi.
 */
function publicAbi(contract, expectedPublic) {
    const actualPublic = [];
    for (const method of contract.interface.abi) {
        if (method.type === 'function') {
            actualPublic.push(method.name);
        }
    }
    for (const method of actualPublic) {
        const index = expectedPublic.indexOf(method);
        chai_1.assert.isAtLeast(index, 0, `#${method} is NOT expected to be public`);
    }
    for (const method of expectedPublic) {
        const index = actualPublic.indexOf(method);
        chai_1.assert.isAtLeast(index, 0, `#${method} is expected to be public`);
    }
}
exports.publicAbi = publicAbi;
/**
 * Assert that an event exists
 *
 * @param receipt The contract receipt to find the event in
 * @param eventDescription A description of the event to search by
 */
function eventExists(receipt, eventDescription) {
    const event = helpers_1.findEventIn(receipt, eventDescription);
    if (!event) {
        throw Error(`Unable to find ${eventDescription.name} in transaction receipt`);
    }
    return event;
}
exports.eventExists = eventExists;
/**
 * Assert that an event doesnt exist
 *
 * @param receipt The contract receipt to find the event in
 * @param eventDescription A description of the event to search by
 */
function eventDoesNotExist(receipt, eventDescription) {
    const event = helpers_1.findEventIn(receipt, eventDescription);
    if (event) {
        throw Error(`Found ${eventDescription.name} in transaction receipt, when expecting no instances`);
    }
}
exports.eventDoesNotExist = eventDoesNotExist;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0Y2hlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbWF0Y2hlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0dBTUc7QUFDSCwrQkFBNkI7QUFDN0IsbUNBQStCO0FBRy9CLG1DQUFtQztBQUNuQyx1Q0FBdUM7QUFDdkMsTUFBTSxLQUFLLEdBQUcsaUJBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQTtBQUVsQzs7Ozs7O0dBTUc7QUFDSCxTQUFnQixNQUFNLENBQ3BCLFFBQXNCLEVBQ3RCLE1BQW9CLEVBQ3BCLGNBQXVCO0lBRXZCLE1BQU0sR0FBRyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO0lBQ3ZELGFBQU0sQ0FDSixlQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsZUFBTSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsRUFDekUsb0JBQW9CLFFBQVEsbUJBQW1CLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FDL0QsQ0FBQTtBQUNILENBQUM7QUFWRCx3QkFVQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLFNBQVMsQ0FDN0IsTUFBMkMsRUFDM0MsR0FBWTtJQUVaLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQTtJQUM1QyxJQUFJLENBQUMsR0FBc0IsU0FBUyxDQUFBO0lBRXBDLElBQUk7UUFDRixJQUFJLE9BQU8sTUFBTSxLQUFLLFVBQVUsRUFBRTtZQUNoQyxNQUFNLE1BQU0sRUFBRSxDQUFBO1NBQ2Y7YUFBTTtZQUNMLE1BQU0sTUFBTSxDQUFBO1NBQ2I7S0FDRjtJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ2QsQ0FBQyxHQUFHLEtBQUssQ0FBQTtLQUNWO0lBQ0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBQ0osSUFBSSxDQUFDLENBQUMsRUFBRTtRQUNOLGFBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLGdDQUFnQyxDQUFDLENBQUE7UUFDbEQsT0FBTTtLQUNQO0lBRUQsYUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsd0NBQXdDLENBQUMsQ0FBQTtJQUUzRCxNQUFNLGNBQWMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQ25ELE1BQU0sVUFBVSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsa0NBQUMsQ0FBQywwQ0FBRSxPQUFPLDBDQUFFLFFBQVEsQ0FBQyxHQUFHLElBQUMsQ0FBQyxDQUFBO0lBRXhFLElBQUksR0FBRyxFQUFFO1FBQ1AsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUE7S0FDL0I7SUFFRCxhQUFNLENBQ0osVUFBVSxFQUNWLCtDQUErQyxjQUFjLENBQUMsSUFBSSxDQUNoRSxNQUFNLENBQ1AsV0FBVyxDQUFDLENBQUMsT0FBTyxHQUFHLENBQ3pCLENBQUE7QUFDSCxDQUFDO0FBckNELDhCQXFDQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsU0FBUyxDQUN2QixRQUFrRCxFQUNsRCxjQUF3QjtJQUV4QixNQUFNLFlBQVksR0FBRyxFQUFFLENBQUE7SUFDdkIsS0FBSyxNQUFNLE1BQU0sSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUMzQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFFO1lBQzlCLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1NBQy9CO0tBQ0Y7SUFFRCxLQUFLLE1BQU0sTUFBTSxJQUFJLFlBQVksRUFBRTtRQUNqQyxNQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQzVDLGFBQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLE1BQU0sK0JBQStCLENBQUMsQ0FBQTtLQUN0RTtJQUVELEtBQUssTUFBTSxNQUFNLElBQUksY0FBYyxFQUFFO1FBQ25DLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDMUMsYUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksTUFBTSwyQkFBMkIsQ0FBQyxDQUFBO0tBQ2xFO0FBQ0gsQ0FBQztBQXBCRCw4QkFvQkM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLFdBQVcsQ0FDekIsT0FBd0IsRUFDeEIsZ0JBQWtDO0lBRWxDLE1BQU0sS0FBSyxHQUFHLHFCQUFXLENBQUMsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUE7SUFDcEQsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sS0FBSyxDQUNULGtCQUFrQixnQkFBZ0IsQ0FBQyxJQUFJLHlCQUF5QixDQUNqRSxDQUFBO0tBQ0Y7SUFFRCxPQUFPLEtBQUssQ0FBQTtBQUNkLENBQUM7QUFaRCxrQ0FZQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQy9CLE9BQXdCLEVBQ3hCLGdCQUFrQztJQUVsQyxNQUFNLEtBQUssR0FBRyxxQkFBVyxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFBO0lBQ3BELElBQUksS0FBSyxFQUFFO1FBQ1QsTUFBTSxLQUFLLENBQ1QsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJLHNEQUFzRCxDQUNyRixDQUFBO0tBQ0Y7QUFDSCxDQUFDO0FBVkQsOENBVUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIG51bWJlciBvZiBtYXRjaGVyIGZ1bmN0aW9ucyBtZWFudCB0byBwZXJmb3JtIGNvbW1vbiBhc3NlcnRpb25zIGZvclxuICogZXRoZXJldW0gYmFzZWQgdGVzdHMuIFNwZWNpZmljIGFzc2VydGlvbiBmdW5jdGlvbnMgdGFyZ2V0aW5nIGNoYWlubGluayBzbWFydCBjb250cmFjdHMgbGl2ZSBpblxuICogdGhlaXIgcmVzcGVjdGl2ZSBjb250cmFjdHMvPGNvbnRyYWN0Pi50cyBmaWxlLlxuICovXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdjaGFpJ1xuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJ1xuaW1wb3J0IHsgQ29udHJhY3RSZWNlaXB0IH0gZnJvbSAnZXRoZXJzL2NvbnRyYWN0J1xuaW1wb3J0IHsgQmlnTnVtYmVyaXNoLCBFdmVudERlc2NyaXB0aW9uIH0gZnJvbSAnZXRoZXJzL3V0aWxzJ1xuaW1wb3J0IHsgbWFrZURlYnVnIH0gZnJvbSAnLi9kZWJ1ZydcbmltcG9ydCB7IGZpbmRFdmVudEluIH0gZnJvbSAnLi9oZWxwZXJzJ1xuY29uc3QgZGVidWcgPSBtYWtlRGVidWcoJ2hlbHBlcnMnKVxuXG4vKipcbiAqIENoZWNrIHRoYXQgdHdvIGJpZyBudW1iZXJzIGFyZSB0aGUgc2FtZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZXhwZWN0ZWQgVGhlIGV4cGVjdGVkIHZhbHVlIHRvIG1hdGNoIGFnYWluc3RcbiAqIEBwYXJhbSBhY3R1YWwgVGhlIGFjdHVhbCB2YWx1ZSB0byBtYXRjaCBhZ2FpbnN0IHRoZSBleHBlY3RlZCB2YWx1ZVxuICogQHBhcmFtIGZhaWx1cmVNZXNzYWdlIEZhaWx1cmUgbWVzc2FnZSB0byBkaXNwbGF5IGlmIHRoZSBhY3R1YWwgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmlnTnVtKFxuICBleHBlY3RlZDogQmlnTnVtYmVyaXNoLFxuICBhY3R1YWw6IEJpZ051bWJlcmlzaCxcbiAgZmFpbHVyZU1lc3NhZ2U/OiBzdHJpbmcsXG4pOiB2b2lkIHtcbiAgY29uc3QgbXNnID0gZmFpbHVyZU1lc3NhZ2UgPyAnOiAnICsgZmFpbHVyZU1lc3NhZ2UgOiAnJ1xuICBhc3NlcnQoXG4gICAgZXRoZXJzLnV0aWxzLmJpZ051bWJlcmlmeShleHBlY3RlZCkuZXEoZXRoZXJzLnV0aWxzLmJpZ051bWJlcmlmeShhY3R1YWwpKSxcbiAgICBgQmlnTnVtIChleHBlY3RlZCkke2V4cGVjdGVkfSBpcyBub3QgKGFjdHVhbCkke2FjdHVhbH0gJHttc2d9YCxcbiAgKVxufVxuXG4vKipcbiAqIENoZWNrIHRoYXQgYW4gZXZtIG9wZXJhdGlvbiByZXZlcnRzXG4gKlxuICogQHBhcmFtIGFjdGlvbiBUaGUgYXN5bmNocm9ub3VzIGFjdGlvbiB0byBleGVjdXRlLCB3aGljaCBzaG91bGQgY2F1c2UgYW4gZXZtIHJldmVydC5cbiAqIEBwYXJhbSBtc2cgVGhlIGZhaWx1cmUgbWVzc2FnZSB0byBkaXNwbGF5IGlmIHRoZSBhY3Rpb24gX19kb2VzIG5vdF9fIHRocm93XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBldm1SZXZlcnQoXG4gIGFjdGlvbjogKCgpID0+IFByb21pc2U8YW55PikgfCBQcm9taXNlPGFueT4sXG4gIG1zZz86IHN0cmluZyxcbikge1xuICBjb25zdCBkID0gZGVidWcuZXh0ZW5kKCdhc3NlcnRBY3Rpb25UaHJvd3MnKVxuICBsZXQgZTogRXJyb3IgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhd2FpdCBhY3Rpb24oKVxuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBhY3Rpb25cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IGVycm9yXG4gIH1cbiAgZChlKVxuICBpZiAoIWUpIHtcbiAgICBhc3NlcnQuZXhpc3RzKGUsICdFeHBlY3RlZCBhbiBlcnJvciB0byBiZSByYWlzZWQnKVxuICAgIHJldHVyblxuICB9XG5cbiAgYXNzZXJ0KGUubWVzc2FnZSwgJ0V4cGVjdGVkIGFuIGVycm9yIHRvIGNvbnRhaW4gYSBtZXNzYWdlJylcblxuICBjb25zdCBFUlJPUl9NRVNTQUdFUyA9IFsnaW52YWxpZCBvcGNvZGUnLCAncmV2ZXJ0J11cbiAgY29uc3QgaGFzRXJyb3JlZCA9IEVSUk9SX01FU1NBR0VTLnNvbWUobXNnID0+IGU/Lm1lc3NhZ2U/LmluY2x1ZGVzKG1zZykpXG5cbiAgaWYgKG1zZykge1xuICAgIGV4cGVjdChlLm1lc3NhZ2UpLnRvTWF0Y2gobXNnKVxuICB9XG5cbiAgYXNzZXJ0KFxuICAgIGhhc0Vycm9yZWQsXG4gICAgYGV4cGVjdGVkIGZvbGxvd2luZyBlcnJvciBtZXNzYWdlIHRvIGluY2x1ZGUgJHtFUlJPUl9NRVNTQUdFUy5qb2luKFxuICAgICAgJyBvciAnLFxuICAgICl9LiBHb3Q6IFwiJHtlLm1lc3NhZ2V9XCJgLFxuICApXG59XG5cbi8qKlxuICogQ2hlY2sgdGhhdCBhIGNvbnRyYWN0J3MgYWJpIGV4cG9zZXMgdGhlIGV4cGVjdGVkIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gY29udHJhY3QgVGhlIGNvbnRyYWN0IHdpdGggdGhlIGFjdHVhbCBhYmkgdG8gY2hlY2sgdGhlIGV4cGVjdGVkIGV4cG9zZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBhZ2FpbnN0LlxuICogQHBhcmFtIGV4cGVjdGVkUHVibGljIFRoZSBleHBlY3RlZCBwdWJsaWMgZXhwb3NlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIHRvIG1hdGNoIGFnYWluc3QgdGhlIGFjdHVhbCBhYmkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdWJsaWNBYmkoXG4gIGNvbnRyYWN0OiBldGhlcnMuQ29udHJhY3QgfCBldGhlcnMuQ29udHJhY3RGYWN0b3J5LFxuICBleHBlY3RlZFB1YmxpYzogc3RyaW5nW10sXG4pIHtcbiAgY29uc3QgYWN0dWFsUHVibGljID0gW11cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgY29udHJhY3QuaW50ZXJmYWNlLmFiaSkge1xuICAgIGlmIChtZXRob2QudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWN0dWFsUHVibGljLnB1c2gobWV0aG9kLm5hbWUpXG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgYWN0dWFsUHVibGljKSB7XG4gICAgY29uc3QgaW5kZXggPSBleHBlY3RlZFB1YmxpYy5pbmRleE9mKG1ldGhvZClcbiAgICBhc3NlcnQuaXNBdExlYXN0KGluZGV4LCAwLCBgIyR7bWV0aG9kfSBpcyBOT1QgZXhwZWN0ZWQgdG8gYmUgcHVibGljYClcbiAgfVxuXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIGV4cGVjdGVkUHVibGljKSB7XG4gICAgY29uc3QgaW5kZXggPSBhY3R1YWxQdWJsaWMuaW5kZXhPZihtZXRob2QpXG4gICAgYXNzZXJ0LmlzQXRMZWFzdChpbmRleCwgMCwgYCMke21ldGhvZH0gaXMgZXhwZWN0ZWQgdG8gYmUgcHVibGljYClcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IGFuIGV2ZW50IGV4aXN0c1xuICpcbiAqIEBwYXJhbSByZWNlaXB0IFRoZSBjb250cmFjdCByZWNlaXB0IHRvIGZpbmQgdGhlIGV2ZW50IGluXG4gKiBAcGFyYW0gZXZlbnREZXNjcmlwdGlvbiBBIGRlc2NyaXB0aW9uIG9mIHRoZSBldmVudCB0byBzZWFyY2ggYnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50RXhpc3RzKFxuICByZWNlaXB0OiBDb250cmFjdFJlY2VpcHQsXG4gIGV2ZW50RGVzY3JpcHRpb246IEV2ZW50RGVzY3JpcHRpb24sXG4pOiBldGhlcnMuRXZlbnQge1xuICBjb25zdCBldmVudCA9IGZpbmRFdmVudEluKHJlY2VpcHQsIGV2ZW50RGVzY3JpcHRpb24pXG4gIGlmICghZXZlbnQpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBVbmFibGUgdG8gZmluZCAke2V2ZW50RGVzY3JpcHRpb24ubmFtZX0gaW4gdHJhbnNhY3Rpb24gcmVjZWlwdGAsXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYW4gZXZlbnQgZG9lc250IGV4aXN0XG4gKlxuICogQHBhcmFtIHJlY2VpcHQgVGhlIGNvbnRyYWN0IHJlY2VpcHQgdG8gZmluZCB0aGUgZXZlbnQgaW5cbiAqIEBwYXJhbSBldmVudERlc2NyaXB0aW9uIEEgZGVzY3JpcHRpb24gb2YgdGhlIGV2ZW50IHRvIHNlYXJjaCBieVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnREb2VzTm90RXhpc3QoXG4gIHJlY2VpcHQ6IENvbnRyYWN0UmVjZWlwdCxcbiAgZXZlbnREZXNjcmlwdGlvbjogRXZlbnREZXNjcmlwdGlvbixcbikge1xuICBjb25zdCBldmVudCA9IGZpbmRFdmVudEluKHJlY2VpcHQsIGV2ZW50RGVzY3JpcHRpb24pXG4gIGlmIChldmVudCkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYEZvdW5kICR7ZXZlbnREZXNjcmlwdGlvbi5uYW1lfSBpbiB0cmFuc2FjdGlvbiByZWNlaXB0LCB3aGVuIGV4cGVjdGluZyBubyBpbnN0YW5jZXNgLFxuICAgIClcbiAgfVxufVxuIl19