"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sol_compiler_1 = require("@0x/sol-compiler");
const path_1 = require("path");
const utils_1 = require("../utils");
const d = utils_1.debug('solc');
/**
 * Generate solidity artifacts for all of the solidity versions under a specified contract
 * directory.
 *
 * @param conf The application configuration, e.g. where to read solidity files, where to output, etc..
 */
async function compileAll(conf) {
    return Promise.all(utils_1.getContractDirs(conf).map(async ({ dir, version }) => {
        const c = compiler(conf, dir, version);
        // Compiler#getCompilerOutputsAsync throws on compilation errors
        // this method prints any errors and warnings for us
        await c.compileAsync();
    }));
}
exports.compileAll = compileAll;
/**
 * Create a sol-compiler instance that reads in a subdirectory of smart contracts e.g. (src/v0.4, src/v0.5, ..)
 * and outputs their respective compiler artifacts e.g. (abi/v0.4, abi/v0.5)
 *
 * @param config The application specific configuration to use for sol-compiler
 * @param subDir The subdirectory to use as a namespace when reading .sol files and outputting
 * their respective artifacts
 * @param solcVersion The solidity compiler version to use with sol-compiler
 */
function compiler({ artifactsDir, useDockerisedSolc, contractsDir, compilerSettings, }, subDir, solcVersion) {
    const _d = d.extend('compiler');
    // remove our custom versions property
    const compilerSettingCopy = JSON.parse(JSON.stringify(compilerSettings));
    delete compilerSettingCopy.versions;
    const settings = {
        artifactsDir: path_1.join(artifactsDir, subDir),
        compilerSettings: {
            outputSelection: {
                '*': {
                    '*': [
                        'abi',
                        'devdoc',
                        'userdoc',
                        'evm.bytecode.object',
                        'evm.bytecode.sourceMap',
                        'evm.deployedBytecode.object',
                        'evm.deployedBytecode.sourceMap',
                        'evm.methodIdentifiers',
                        'metadata',
                    ],
                },
            },
            ...compilerSettingCopy,
        },
        contracts: '*',
        contractsDir: path_1.join(contractsDir, subDir),
        isOfflineMode: false,
        shouldSaveStandardInput: false,
        solcVersion,
        useDockerisedSolc,
    };
    _d('Settings: %o', settings);
    return new sol_compiler_1.Compiler(settings);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29sYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9jb21waWxlcnMvc29sYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLG1EQUE0RDtBQUM1RCwrQkFBMkI7QUFFM0Isb0NBQWlEO0FBQ2pELE1BQU0sQ0FBQyxHQUFHLGFBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUV2Qjs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxVQUFVLENBQUMsSUFBZ0I7SUFDL0MsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUNoQix1QkFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRTtRQUNuRCxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQTtRQUV0QyxnRUFBZ0U7UUFDaEUsb0RBQW9EO1FBQ3BELE1BQU0sQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFBO0lBQ3hCLENBQUMsQ0FBQyxDQUNILENBQUE7QUFDSCxDQUFDO0FBVkQsZ0NBVUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILFNBQVMsUUFBUSxDQUNmLEVBQ0UsWUFBWSxFQUNaLGlCQUFpQixFQUNqQixZQUFZLEVBQ1osZ0JBQWdCLEdBQ0wsRUFDYixNQUFjLEVBQ2QsV0FBbUI7SUFFbkIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUMvQixzQ0FBc0M7SUFDdEMsTUFBTSxtQkFBbUIsR0FBbUMsSUFBSSxDQUFDLEtBQUssQ0FDcEUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUNqQyxDQUFBO0lBQ0QsT0FBTyxtQkFBbUIsQ0FBQyxRQUFRLENBQUE7SUFFbkMsTUFBTSxRQUFRLEdBQW9CO1FBQ2hDLFlBQVksRUFBRSxXQUFJLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQztRQUN4QyxnQkFBZ0IsRUFBRTtZQUNoQixlQUFlLEVBQUU7Z0JBQ2YsR0FBRyxFQUFFO29CQUNILEdBQUcsRUFBRTt3QkFDSCxLQUFLO3dCQUNMLFFBQVE7d0JBQ1IsU0FBUzt3QkFDVCxxQkFBcUI7d0JBQ3JCLHdCQUF3Qjt3QkFDeEIsNkJBQTZCO3dCQUM3QixnQ0FBZ0M7d0JBQ2hDLHVCQUF1Qjt3QkFDdkIsVUFBVTtxQkFDWDtpQkFDRjthQUNGO1lBQ0QsR0FBRyxtQkFBbUI7U0FDdkI7UUFDRCxTQUFTLEVBQUUsR0FBRztRQUNkLFlBQVksRUFBRSxXQUFJLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQztRQUN4QyxhQUFhLEVBQUUsS0FBSztRQUNwQix1QkFBdUIsRUFBRSxLQUFLO1FBQzlCLFdBQVc7UUFDWCxpQkFBaUI7S0FDbEIsQ0FBQTtJQUNELEVBQUUsQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDLENBQUE7SUFFNUIsT0FBTyxJQUFJLHVCQUFRLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDL0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBpbGVyLCBDb21waWxlck9wdGlvbnMgfSBmcm9tICdAMHgvc29sLWNvbXBpbGVyJ1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi4vY29uZmlnJ1xuaW1wb3J0IHsgZGVidWcsIGdldENvbnRyYWN0RGlycyB9IGZyb20gJy4uL3V0aWxzJ1xuY29uc3QgZCA9IGRlYnVnKCdzb2xjJylcblxuLyoqXG4gKiBHZW5lcmF0ZSBzb2xpZGl0eSBhcnRpZmFjdHMgZm9yIGFsbCBvZiB0aGUgc29saWRpdHkgdmVyc2lvbnMgdW5kZXIgYSBzcGVjaWZpZWQgY29udHJhY3RcbiAqIGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0gY29uZiBUaGUgYXBwbGljYXRpb24gY29uZmlndXJhdGlvbiwgZS5nLiB3aGVyZSB0byByZWFkIHNvbGlkaXR5IGZpbGVzLCB3aGVyZSB0byBvdXRwdXQsIGV0Yy4uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21waWxlQWxsKGNvbmY6IGNvbmZpZy5BcHApIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIGdldENvbnRyYWN0RGlycyhjb25mKS5tYXAoYXN5bmMgKHsgZGlyLCB2ZXJzaW9uIH0pID0+IHtcbiAgICAgIGNvbnN0IGMgPSBjb21waWxlcihjb25mLCBkaXIsIHZlcnNpb24pXG5cbiAgICAgIC8vIENvbXBpbGVyI2dldENvbXBpbGVyT3V0cHV0c0FzeW5jIHRocm93cyBvbiBjb21waWxhdGlvbiBlcnJvcnNcbiAgICAgIC8vIHRoaXMgbWV0aG9kIHByaW50cyBhbnkgZXJyb3JzIGFuZCB3YXJuaW5ncyBmb3IgdXNcbiAgICAgIGF3YWl0IGMuY29tcGlsZUFzeW5jKClcbiAgICB9KSxcbiAgKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNvbC1jb21waWxlciBpbnN0YW5jZSB0aGF0IHJlYWRzIGluIGEgc3ViZGlyZWN0b3J5IG9mIHNtYXJ0IGNvbnRyYWN0cyBlLmcuIChzcmMvdjAuNCwgc3JjL3YwLjUsIC4uKVxuICogYW5kIG91dHB1dHMgdGhlaXIgcmVzcGVjdGl2ZSBjb21waWxlciBhcnRpZmFjdHMgZS5nLiAoYWJpL3YwLjQsIGFiaS92MC41KVxuICpcbiAqIEBwYXJhbSBjb25maWcgVGhlIGFwcGxpY2F0aW9uIHNwZWNpZmljIGNvbmZpZ3VyYXRpb24gdG8gdXNlIGZvciBzb2wtY29tcGlsZXJcbiAqIEBwYXJhbSBzdWJEaXIgVGhlIHN1YmRpcmVjdG9yeSB0byB1c2UgYXMgYSBuYW1lc3BhY2Ugd2hlbiByZWFkaW5nIC5zb2wgZmlsZXMgYW5kIG91dHB1dHRpbmdcbiAqIHRoZWlyIHJlc3BlY3RpdmUgYXJ0aWZhY3RzXG4gKiBAcGFyYW0gc29sY1ZlcnNpb24gVGhlIHNvbGlkaXR5IGNvbXBpbGVyIHZlcnNpb24gdG8gdXNlIHdpdGggc29sLWNvbXBpbGVyXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVyKFxuICB7XG4gICAgYXJ0aWZhY3RzRGlyLFxuICAgIHVzZURvY2tlcmlzZWRTb2xjLFxuICAgIGNvbnRyYWN0c0RpcixcbiAgICBjb21waWxlclNldHRpbmdzLFxuICB9OiBjb25maWcuQXBwLFxuICBzdWJEaXI6IHN0cmluZyxcbiAgc29sY1ZlcnNpb246IHN0cmluZyxcbikge1xuICBjb25zdCBfZCA9IGQuZXh0ZW5kKCdjb21waWxlcicpXG4gIC8vIHJlbW92ZSBvdXIgY3VzdG9tIHZlcnNpb25zIHByb3BlcnR5XG4gIGNvbnN0IGNvbXBpbGVyU2V0dGluZ0NvcHk6IGNvbmZpZy5BcHBbJ2NvbXBpbGVyU2V0dGluZ3MnXSA9IEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkoY29tcGlsZXJTZXR0aW5ncyksXG4gIClcbiAgZGVsZXRlIGNvbXBpbGVyU2V0dGluZ0NvcHkudmVyc2lvbnNcblxuICBjb25zdCBzZXR0aW5nczogQ29tcGlsZXJPcHRpb25zID0ge1xuICAgIGFydGlmYWN0c0Rpcjogam9pbihhcnRpZmFjdHNEaXIsIHN1YkRpciksXG4gICAgY29tcGlsZXJTZXR0aW5nczoge1xuICAgICAgb3V0cHV0U2VsZWN0aW9uOiB7XG4gICAgICAgICcqJzoge1xuICAgICAgICAgICcqJzogW1xuICAgICAgICAgICAgJ2FiaScsXG4gICAgICAgICAgICAnZGV2ZG9jJyxcbiAgICAgICAgICAgICd1c2VyZG9jJyxcbiAgICAgICAgICAgICdldm0uYnl0ZWNvZGUub2JqZWN0JyxcbiAgICAgICAgICAgICdldm0uYnl0ZWNvZGUuc291cmNlTWFwJyxcbiAgICAgICAgICAgICdldm0uZGVwbG95ZWRCeXRlY29kZS5vYmplY3QnLFxuICAgICAgICAgICAgJ2V2bS5kZXBsb3llZEJ5dGVjb2RlLnNvdXJjZU1hcCcsXG4gICAgICAgICAgICAnZXZtLm1ldGhvZElkZW50aWZpZXJzJyxcbiAgICAgICAgICAgICdtZXRhZGF0YScsXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAuLi5jb21waWxlclNldHRpbmdDb3B5LFxuICAgIH0sXG4gICAgY29udHJhY3RzOiAnKicsXG4gICAgY29udHJhY3RzRGlyOiBqb2luKGNvbnRyYWN0c0Rpciwgc3ViRGlyKSxcbiAgICBpc09mZmxpbmVNb2RlOiBmYWxzZSxcbiAgICBzaG91bGRTYXZlU3RhbmRhcmRJbnB1dDogZmFsc2UsXG4gICAgc29sY1ZlcnNpb24sXG4gICAgdXNlRG9ja2VyaXNlZFNvbGMsXG4gIH1cbiAgX2QoJ1NldHRpbmdzOiAlbycsIHNldHRpbmdzKVxuXG4gIHJldHVybiBuZXcgQ29tcGlsZXIoc2V0dGluZ3MpXG59XG4iXX0=